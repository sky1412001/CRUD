{"ast":null,"code":"/*\n * Copyright 2015 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { AbstractPureComponent, Classes, DISPLAYNAME_PREFIX, Utils } from \"../../common\";\nimport { Tab } from \"./tab\";\nimport { generateTabPanelId, generateTabTitleId, TabTitle } from \"./tabTitle\";\n/**\n * Component that may be inserted between any two children of `<Tabs>` to right-align all subsequent children.\n */\nexport var TabsExpander = function () {\n  return React.createElement(\"div\", {\n    className: Classes.FLEX_EXPANDER\n  });\n};\n/** @deprecated use `TabsExpander` instead */\nexport var Expander = TabsExpander;\nvar TAB_SELECTOR = \".\".concat(Classes.TAB);\n/**\n * Tabs component.\n *\n * @see https://blueprintjs.com/docs/#core/components/tabs\n */\nvar Tabs = /** @class */function (_super) {\n  __extends(Tabs, _super);\n  function Tabs(props) {\n    var _this = _super.call(this, props) || this;\n    _this.tablistElement = null;\n    _this.refHandlers = {\n      tablist: function (tabElement) {\n        return _this.tablistElement = tabElement;\n      }\n    };\n    _this.handleKeyDown = function (e) {\n      var _a;\n      var focusedElement = (_a = Utils.getActiveElement(_this.tablistElement)) === null || _a === void 0 ? void 0 : _a.closest(TAB_SELECTOR);\n      // rest of this is potentially expensive and futile, so bail if no tab is focused\n      if (focusedElement == null) {\n        return;\n      }\n      // must rely on DOM state because we have no way of mapping `focusedElement` to a JSX.Element\n      var enabledTabElements = _this.getTabElements().filter(function (el) {\n        return el.getAttribute(\"aria-disabled\") === \"false\";\n      });\n      var focusedIndex = enabledTabElements.indexOf(focusedElement);\n      var direction = _this.getKeyCodeDirection(e);\n      if (focusedIndex >= 0 && direction !== undefined) {\n        e.preventDefault();\n        var length_1 = enabledTabElements.length;\n        // auto-wrapping at 0 and `length`\n        var nextFocusedIndex = (focusedIndex + direction + length_1) % length_1;\n        enabledTabElements[nextFocusedIndex].focus();\n      }\n    };\n    _this.handleKeyPress = function (e) {\n      var targetTabElement = e.target.closest(TAB_SELECTOR);\n      if (targetTabElement != null && Utils.isKeyboardClick(e)) {\n        e.preventDefault();\n        targetTabElement.click();\n      }\n    };\n    _this.handleTabClick = function (newTabId, event) {\n      var _a, _b;\n      (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, newTabId, _this.state.selectedTabId, event);\n      if (_this.props.selectedTabId === undefined) {\n        _this.setState({\n          selectedTabId: newTabId\n        });\n      }\n    };\n    _this.renderTabPanel = function (tab) {\n      var _a = tab.props,\n        className = _a.className,\n        panel = _a.panel,\n        id = _a.id,\n        panelClassName = _a.panelClassName;\n      if (panel === undefined) {\n        return undefined;\n      }\n      return React.createElement(\"div\", {\n        \"aria-labelledby\": generateTabTitleId(_this.props.id, id),\n        \"aria-hidden\": id !== _this.state.selectedTabId,\n        className: classNames(Classes.TAB_PANEL, className, panelClassName),\n        id: generateTabPanelId(_this.props.id, id),\n        key: id,\n        role: \"tabpanel\"\n      }, panel);\n    };\n    _this.renderTabTitle = function (child) {\n      if (isTabElement(child)) {\n        var id = child.props.id;\n        return React.createElement(TabTitle, __assign({}, child.props, {\n          parentId: _this.props.id,\n          onClick: _this.handleTabClick,\n          selected: id === _this.state.selectedTabId\n        }));\n      }\n      return child;\n    };\n    var selectedTabId = _this.getInitialSelectedTabId();\n    _this.state = {\n      selectedTabId: selectedTabId\n    };\n    return _this;\n  }\n  Tabs.getDerivedStateFromProps = function (_a) {\n    var selectedTabId = _a.selectedTabId;\n    if (selectedTabId !== undefined) {\n      // keep state in sync with controlled prop, so state is canonical source of truth\n      return {\n        selectedTabId: selectedTabId\n      };\n    }\n    return null;\n  };\n  Tabs.prototype.render = function () {\n    var _a, _b;\n    var _c = this.state,\n      indicatorWrapperStyle = _c.indicatorWrapperStyle,\n      selectedTabId = _c.selectedTabId;\n    var tabTitles = React.Children.map(this.props.children, this.renderTabTitle);\n    var tabPanels = this.getTabChildren().filter(this.props.renderActiveTabPanelOnly ? function (tab) {\n      return tab.props.id === selectedTabId;\n    } : function () {\n      return true;\n    }).map(this.renderTabPanel);\n    var tabIndicator = this.props.animate ? React.createElement(\"div\", {\n      className: Classes.TAB_INDICATOR_WRAPPER,\n      style: indicatorWrapperStyle\n    }, React.createElement(\"div\", {\n      className: Classes.TAB_INDICATOR\n    })) : null;\n    var classes = classNames(Classes.TABS, this.props.className, (_a = {}, _a[Classes.VERTICAL] = this.props.vertical, _a[Classes.FILL] = this.props.fill, _a));\n    var tabListClasses = classNames(Classes.TAB_LIST, (_b = {}, _b[Classes.LARGE] = this.props.large, _b));\n    return React.createElement(\"div\", {\n      className: classes\n    }, React.createElement(\"div\", {\n      className: tabListClasses,\n      onKeyDown: this.handleKeyDown,\n      onKeyPress: this.handleKeyPress,\n      ref: this.refHandlers.tablist,\n      role: \"tablist\"\n    }, tabIndicator, tabTitles), tabPanels);\n  };\n  Tabs.prototype.componentDidMount = function () {\n    this.moveSelectionIndicator(false);\n  };\n  Tabs.prototype.componentDidUpdate = function (prevProps, prevState) {\n    if (this.state.selectedTabId !== prevState.selectedTabId) {\n      this.moveSelectionIndicator();\n    } else if (prevState.selectedTabId != null) {\n      // comparing React nodes is difficult to do with simple logic, so\n      // shallowly compare just their props as a workaround.\n      var didChildrenChange = !Utils.arraysEqual(this.getTabChildrenProps(prevProps), this.getTabChildrenProps(), Utils.shallowCompareKeys);\n      if (didChildrenChange) {\n        this.moveSelectionIndicator();\n      }\n    }\n  };\n  Tabs.prototype.getInitialSelectedTabId = function () {\n    // NOTE: providing an unknown ID will hide the selection\n    var _a = this.props,\n      defaultSelectedTabId = _a.defaultSelectedTabId,\n      selectedTabId = _a.selectedTabId;\n    if (selectedTabId !== undefined) {\n      return selectedTabId;\n    } else if (defaultSelectedTabId !== undefined) {\n      return defaultSelectedTabId;\n    } else {\n      // select first tab in absence of user input\n      var tabs = this.getTabChildren();\n      return tabs.length === 0 ? undefined : tabs[0].props.id;\n    }\n  };\n  Tabs.prototype.getKeyCodeDirection = function (e) {\n    if (e.key === \"ArrowLeft\" || e.key === \"ArrowUp\") {\n      return -1;\n    } else if (e.key === \"ArrowRight\" || e.key === \"ArrowDown\") {\n      return 1;\n    }\n    return undefined;\n  };\n  Tabs.prototype.getTabChildrenProps = function (props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n    return this.getTabChildren(props).map(function (child) {\n      return child.props;\n    });\n  };\n  /** Filters children to only `<Tab>`s */\n  Tabs.prototype.getTabChildren = function (props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n    return React.Children.toArray(props.children).filter(isTabElement);\n  };\n  /** Queries root HTML element for all tabs with optional filter selector */\n  Tabs.prototype.getTabElements = function (subselector) {\n    if (subselector === void 0) {\n      subselector = \"\";\n    }\n    if (this.tablistElement == null) {\n      return [];\n    }\n    return Array.from(this.tablistElement.querySelectorAll(TAB_SELECTOR + subselector));\n  };\n  /**\n   * Calculate the new height, width, and position of the tab indicator.\n   * Store the CSS values so the transition animation can start.\n   */\n  Tabs.prototype.moveSelectionIndicator = function (animate) {\n    if (animate === void 0) {\n      animate = true;\n    }\n    if (this.tablistElement == null || !this.props.animate) {\n      return;\n    }\n    var tabIdSelector = \"\".concat(TAB_SELECTOR, \"[data-tab-id=\\\"\").concat(this.state.selectedTabId, \"\\\"]\");\n    var selectedTabElement = this.tablistElement.querySelector(tabIdSelector);\n    var indicatorWrapperStyle = {\n      display: \"none\"\n    };\n    if (selectedTabElement != null) {\n      var clientHeight = selectedTabElement.clientHeight,\n        clientWidth = selectedTabElement.clientWidth,\n        offsetLeft = selectedTabElement.offsetLeft,\n        offsetTop = selectedTabElement.offsetTop;\n      indicatorWrapperStyle = {\n        height: clientHeight,\n        transform: \"translateX(\".concat(Math.floor(offsetLeft), \"px) translateY(\").concat(Math.floor(offsetTop), \"px)\"),\n        width: clientWidth\n      };\n      if (!animate) {\n        indicatorWrapperStyle.transition = \"none\";\n      }\n    }\n    this.setState({\n      indicatorWrapperStyle: indicatorWrapperStyle\n    });\n  };\n  /** Insert a `Tabs.Expander` between any two children to right-align all subsequent children. */\n  Tabs.Expander = TabsExpander;\n  Tabs.Tab = Tab;\n  Tabs.defaultProps = {\n    animate: true,\n    fill: false,\n    large: false,\n    renderActiveTabPanelOnly: false,\n    vertical: false\n  };\n  Tabs.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".Tabs\");\n  return Tabs;\n}(AbstractPureComponent);\nexport { Tabs };\nfunction isTabElement(child) {\n  return Utils.isElementOfType(child, Tab);\n}","map":{"version":3,"names":["classNames","React","AbstractPureComponent","Classes","DISPLAYNAME_PREFIX","Utils","Tab","generateTabPanelId","generateTabTitleId","TabTitle","TabsExpander","createElement","className","FLEX_EXPANDER","Expander","TAB_SELECTOR","concat","TAB","Tabs","_super","__extends","props","_this","call","tablistElement","refHandlers","tablist","tabElement","handleKeyDown","e","focusedElement","_a","getActiveElement","closest","enabledTabElements","getTabElements","filter","el","getAttribute","focusedIndex","indexOf","direction","getKeyCodeDirection","undefined","preventDefault","length_1","length","nextFocusedIndex","focus","handleKeyPress","targetTabElement","target","isKeyboardClick","click","handleTabClick","newTabId","event","_b","onChange","state","selectedTabId","setState","renderTabPanel","tab","panel","id","panelClassName","TAB_PANEL","key","role","renderTabTitle","child","isTabElement","__assign","parentId","onClick","selected","getInitialSelectedTabId","getDerivedStateFromProps","prototype","render","_c","indicatorWrapperStyle","tabTitles","Children","map","children","tabPanels","getTabChildren","renderActiveTabPanelOnly","tabIndicator","animate","TAB_INDICATOR_WRAPPER","style","TAB_INDICATOR","classes","TABS","VERTICAL","vertical","FILL","fill","tabListClasses","TAB_LIST","LARGE","large","onKeyDown","onKeyPress","ref","componentDidMount","moveSelectionIndicator","componentDidUpdate","prevProps","prevState","didChildrenChange","arraysEqual","getTabChildrenProps","shallowCompareKeys","defaultSelectedTabId","tabs","toArray","subselector","Array","from","querySelectorAll","tabIdSelector","selectedTabElement","querySelector","display","clientHeight","clientWidth","offsetLeft","offsetTop","height","transform","Math","floor","width","transition","defaultProps","displayName","isElementOfType"],"sources":["/home/meander/Desktop/Akash/Workit/my-app/node_modules/@blueprintjs/core/src/components/tabs/tabs.tsx"],"sourcesContent":["/*\n * Copyright 2015 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport { AbstractPureComponent, Classes, DISPLAYNAME_PREFIX, Props, Utils } from \"../../common\";\nimport { Tab, TabId, TabProps } from \"./tab\";\nimport { generateTabPanelId, generateTabTitleId, TabTitle } from \"./tabTitle\";\n\n/**\n * Component that may be inserted between any two children of `<Tabs>` to right-align all subsequent children.\n */\nexport const TabsExpander: React.FC = () => <div className={Classes.FLEX_EXPANDER} />;\n\n/** @deprecated use `TabsExpander` instead */\nexport const Expander = TabsExpander;\n\ntype TabElement = React.ReactElement<TabProps & { children: React.ReactNode }>;\n\nconst TAB_SELECTOR = `.${Classes.TAB}`;\n\nexport interface TabsProps extends Props {\n    /**\n     * Whether the selected tab indicator should animate its movement.\n     *\n     * @default true\n     */\n    animate?: boolean;\n\n    /** Tab elements. */\n    children?: React.ReactNode;\n\n    /**\n     * Initial selected tab `id`, for uncontrolled usage.\n     * Note that this prop refers only to `<Tab>` children; other types of elements are ignored.\n     *\n     * @default first tab\n     */\n    defaultSelectedTabId?: TabId;\n\n    /**\n     * Unique identifier for this `Tabs` container. This will be combined with the `id` of each\n     * `Tab` child to generate ARIA accessibility attributes. Dsare required and should be\n     * unique on the page to support server-side rendering.\n     */\n    id: TabId;\n\n    /**\n     * If set to `true`, the tab titles will display with larger styling.\n     * This will apply large styles only to the tabs at this level, not to nested tabs.\n     *\n     * @default false\n     */\n    large?: boolean;\n\n    /**\n     * Whether inactive tab panels should be removed from the DOM and unmounted in React.\n     * This can be a performance enhancement when rendering many complex panels, but requires\n     * careful support for unmounting and remounting.\n     *\n     * @default false\n     */\n    renderActiveTabPanelOnly?: boolean;\n\n    /**\n     * Selected tab `id`, for controlled usage.\n     * Providing this prop will put the component in controlled mode.\n     * Unknown ids will result in empty selection (no errors).\n     */\n    selectedTabId?: TabId;\n\n    /**\n     * Whether to show tabs stacked vertically on the left side.\n     *\n     * @default false\n     */\n    vertical?: boolean;\n\n    /**\n     * Whether to make the tabs list fill the height of its parent.\n     *\n     * This has no effect when `vertical={true}`.\n     * This is not recommended when tab panels are defined within this component subtree, as the height computation will\n     * include the panel height, which is usually not intended. Instead, it works well if the panels are rendered\n     * elsewhere in the React tree.\n     *\n     * @default false\n     */\n    fill?: boolean;\n\n    /**\n     * A callback function that is invoked when a tab in the tab list is clicked.\n     */\n    onChange?(newTabId: TabId, prevTabId: TabId | undefined, event: React.MouseEvent<HTMLElement>): void;\n}\n\nexport interface TabsState {\n    indicatorWrapperStyle?: React.CSSProperties;\n    selectedTabId?: TabId;\n}\n\n/**\n * Tabs component.\n *\n * @see https://blueprintjs.com/docs/#core/components/tabs\n */\nexport class Tabs extends AbstractPureComponent<TabsProps, TabsState> {\n    /** Insert a `Tabs.Expander` between any two children to right-align all subsequent children. */\n    public static Expander = TabsExpander;\n\n    public static Tab = Tab;\n\n    public static defaultProps: Partial<TabsProps> = {\n        animate: true,\n        fill: false,\n        large: false,\n        renderActiveTabPanelOnly: false,\n        vertical: false,\n    };\n\n    public static displayName = `${DISPLAYNAME_PREFIX}.Tabs`;\n\n    public static getDerivedStateFromProps({ selectedTabId }: TabsProps) {\n        if (selectedTabId !== undefined) {\n            // keep state in sync with controlled prop, so state is canonical source of truth\n            return { selectedTabId };\n        }\n        return null;\n    }\n\n    private tablistElement: HTMLDivElement | null = null;\n\n    private refHandlers = {\n        tablist: (tabElement: HTMLDivElement) => (this.tablistElement = tabElement),\n    };\n\n    constructor(props: TabsProps) {\n        super(props);\n        const selectedTabId = this.getInitialSelectedTabId();\n        this.state = { selectedTabId };\n    }\n\n    public render() {\n        const { indicatorWrapperStyle, selectedTabId } = this.state;\n\n        const tabTitles = React.Children.map(this.props.children, this.renderTabTitle);\n\n        const tabPanels = this.getTabChildren()\n            .filter(this.props.renderActiveTabPanelOnly ? tab => tab.props.id === selectedTabId : () => true)\n            .map(this.renderTabPanel);\n\n        const tabIndicator = this.props.animate ? (\n            <div className={Classes.TAB_INDICATOR_WRAPPER} style={indicatorWrapperStyle}>\n                <div className={Classes.TAB_INDICATOR} />\n            </div>\n        ) : null;\n\n        const classes = classNames(Classes.TABS, this.props.className, {\n            [Classes.VERTICAL]: this.props.vertical,\n            [Classes.FILL]: this.props.fill,\n        });\n        const tabListClasses = classNames(Classes.TAB_LIST, {\n            [Classes.LARGE]: this.props.large,\n        });\n\n        return (\n            <div className={classes}>\n                <div\n                    className={tabListClasses}\n                    onKeyDown={this.handleKeyDown}\n                    onKeyPress={this.handleKeyPress}\n                    ref={this.refHandlers.tablist}\n                    role=\"tablist\"\n                >\n                    {tabIndicator}\n                    {tabTitles}\n                </div>\n                {tabPanels}\n            </div>\n        );\n    }\n\n    public componentDidMount() {\n        this.moveSelectionIndicator(false);\n    }\n\n    public componentDidUpdate(prevProps: TabsProps, prevState: TabsState) {\n        if (this.state.selectedTabId !== prevState.selectedTabId) {\n            this.moveSelectionIndicator();\n        } else if (prevState.selectedTabId != null) {\n            // comparing React nodes is difficult to do with simple logic, so\n            // shallowly compare just their props as a workaround.\n            const didChildrenChange = !Utils.arraysEqual(\n                this.getTabChildrenProps(prevProps),\n                this.getTabChildrenProps(),\n                Utils.shallowCompareKeys,\n            );\n            if (didChildrenChange) {\n                this.moveSelectionIndicator();\n            }\n        }\n    }\n\n    private getInitialSelectedTabId() {\n        // NOTE: providing an unknown ID will hide the selection\n        const { defaultSelectedTabId, selectedTabId } = this.props;\n        if (selectedTabId !== undefined) {\n            return selectedTabId;\n        } else if (defaultSelectedTabId !== undefined) {\n            return defaultSelectedTabId;\n        } else {\n            // select first tab in absence of user input\n            const tabs = this.getTabChildren();\n            return tabs.length === 0 ? undefined : tabs[0].props.id;\n        }\n    }\n\n    private getKeyCodeDirection(e: React.KeyboardEvent<HTMLElement>) {\n        if (e.key === \"ArrowLeft\" || e.key === \"ArrowUp\") {\n            return -1;\n        } else if (e.key === \"ArrowRight\" || e.key === \"ArrowDown\") {\n            return 1;\n        }\n        return undefined;\n    }\n\n    private getTabChildrenProps(props: TabsProps & { children?: React.ReactNode } = this.props) {\n        return this.getTabChildren(props).map(child => child.props);\n    }\n\n    /** Filters children to only `<Tab>`s */\n    private getTabChildren(props: TabsProps & { children?: React.ReactNode } = this.props) {\n        return React.Children.toArray(props.children).filter(isTabElement);\n    }\n\n    /** Queries root HTML element for all tabs with optional filter selector */\n    private getTabElements(subselector = \"\") {\n        if (this.tablistElement == null) {\n            return [];\n        }\n        return Array.from(this.tablistElement.querySelectorAll(TAB_SELECTOR + subselector));\n    }\n\n    private handleKeyDown = (e: React.KeyboardEvent<HTMLDivElement>) => {\n        const focusedElement = Utils.getActiveElement(this.tablistElement)?.closest(TAB_SELECTOR);\n        // rest of this is potentially expensive and futile, so bail if no tab is focused\n        if (focusedElement == null) {\n            return;\n        }\n\n        // must rely on DOM state because we have no way of mapping `focusedElement` to a JSX.Element\n        const enabledTabElements = this.getTabElements().filter(el => el.getAttribute(\"aria-disabled\") === \"false\");\n        const focusedIndex = enabledTabElements.indexOf(focusedElement);\n        const direction = this.getKeyCodeDirection(e);\n\n        if (focusedIndex >= 0 && direction !== undefined) {\n            e.preventDefault();\n            const { length } = enabledTabElements;\n            // auto-wrapping at 0 and `length`\n            const nextFocusedIndex = (focusedIndex + direction + length) % length;\n            (enabledTabElements[nextFocusedIndex] as HTMLElement).focus();\n        }\n    };\n\n    private handleKeyPress = (e: React.KeyboardEvent<HTMLDivElement>) => {\n        const targetTabElement = (e.target as HTMLElement).closest<HTMLElement>(TAB_SELECTOR);\n        if (targetTabElement != null && Utils.isKeyboardClick(e)) {\n            e.preventDefault();\n            targetTabElement.click();\n        }\n    };\n\n    private handleTabClick = (newTabId: TabId, event: React.MouseEvent<HTMLElement>) => {\n        this.props.onChange?.(newTabId, this.state.selectedTabId, event);\n        if (this.props.selectedTabId === undefined) {\n            this.setState({ selectedTabId: newTabId });\n        }\n    };\n\n    /**\n     * Calculate the new height, width, and position of the tab indicator.\n     * Store the CSS values so the transition animation can start.\n     */\n    private moveSelectionIndicator(animate = true) {\n        if (this.tablistElement == null || !this.props.animate) {\n            return;\n        }\n\n        const tabIdSelector = `${TAB_SELECTOR}[data-tab-id=\"${this.state.selectedTabId}\"]`;\n        const selectedTabElement = this.tablistElement.querySelector<HTMLElement>(tabIdSelector);\n\n        let indicatorWrapperStyle: React.CSSProperties = { display: \"none\" };\n        if (selectedTabElement != null) {\n            const { clientHeight, clientWidth, offsetLeft, offsetTop } = selectedTabElement;\n            indicatorWrapperStyle = {\n                height: clientHeight,\n                transform: `translateX(${Math.floor(offsetLeft)}px) translateY(${Math.floor(offsetTop)}px)`,\n                width: clientWidth,\n            };\n\n            if (!animate) {\n                indicatorWrapperStyle.transition = \"none\";\n            }\n        }\n        this.setState({ indicatorWrapperStyle });\n    }\n\n    private renderTabPanel = (tab: TabElement) => {\n        const { className, panel, id, panelClassName } = tab.props;\n        if (panel === undefined) {\n            return undefined;\n        }\n        return (\n            <div\n                aria-labelledby={generateTabTitleId(this.props.id, id)}\n                aria-hidden={id !== this.state.selectedTabId}\n                className={classNames(Classes.TAB_PANEL, className, panelClassName)}\n                id={generateTabPanelId(this.props.id, id)}\n                key={id}\n                role=\"tabpanel\"\n            >\n                {panel}\n            </div>\n        );\n    };\n\n    private renderTabTitle = (child: React.ReactNode) => {\n        if (isTabElement(child)) {\n            const { id } = child.props;\n            return (\n                <TabTitle\n                    {...child.props}\n                    parentId={this.props.id}\n                    onClick={this.handleTabClick}\n                    selected={id === this.state.selectedTabId}\n                />\n            );\n        }\n        return child;\n    };\n}\n\nfunction isTabElement(child: any): child is TabElement {\n    return Utils.isElementOfType(child, Tab);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}