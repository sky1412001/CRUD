{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { AbstractPureComponent, Classes } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { clamp } from \"../../common/utils\";\nvar BUFFER_WIDTH_DEFAULT = 5;\n/**\n * EditableText component.\n *\n * @see https://blueprintjs.com/docs/#core/components/editable-text\n */\nvar EditableText = /** @class */function (_super) {\n  __extends(EditableText, _super);\n  function EditableText(props) {\n    var _this = _super.call(this, props) || this;\n    _this.inputElement = null;\n    _this.valueElement = null;\n    _this.refHandlers = {\n      content: function (spanElement) {\n        _this.valueElement = spanElement;\n      },\n      input: function (input) {\n        if (input != null) {\n          _this.inputElement = input;\n          // temporary fix for #3882\n          if (!_this.props.alwaysRenderInput) {\n            _this.inputElement.focus();\n          }\n          if (_this.state != null && _this.state.isEditing) {\n            var supportsSelection = inputSupportsSelection(input);\n            if (supportsSelection) {\n              var length_1 = input.value.length;\n              input.setSelectionRange(_this.props.selectAllOnFocus ? 0 : length_1, length_1);\n            }\n            if (!supportsSelection || !_this.props.selectAllOnFocus) {\n              input.scrollLeft = input.scrollWidth;\n            }\n          }\n        }\n      }\n    };\n    _this.cancelEditing = function () {\n      var _a, _b, _c, _d;\n      var _e = _this.state,\n        lastValue = _e.lastValue,\n        value = _e.value;\n      _this.setState({\n        isEditing: false,\n        value: lastValue\n      });\n      if (value !== lastValue) {\n        (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, lastValue);\n      }\n      (_d = (_c = _this.props).onCancel) === null || _d === void 0 ? void 0 : _d.call(_c, lastValue);\n    };\n    _this.toggleEditing = function () {\n      var _a, _b;\n      if (_this.state.isEditing) {\n        var value = _this.state.value;\n        _this.setState({\n          isEditing: false,\n          lastValue: value\n        });\n        (_b = (_a = _this.props).onConfirm) === null || _b === void 0 ? void 0 : _b.call(_a, value);\n      } else if (!_this.props.disabled) {\n        _this.setState({\n          isEditing: true\n        });\n      }\n    };\n    _this.handleFocus = function () {\n      var _a = _this.props,\n        alwaysRenderInput = _a.alwaysRenderInput,\n        disabled = _a.disabled,\n        selectAllOnFocus = _a.selectAllOnFocus;\n      if (!disabled) {\n        _this.setState({\n          isEditing: true\n        });\n      }\n      if (alwaysRenderInput && selectAllOnFocus && _this.inputElement != null) {\n        var length_2 = _this.inputElement.value.length;\n        _this.inputElement.setSelectionRange(0, length_2);\n      }\n    };\n    _this.handleTextChange = function (event) {\n      var _a, _b;\n      var value = event.target.value;\n      // state value should be updated only when uncontrolled\n      if (_this.props.value == null) {\n        _this.setState({\n          value: value\n        });\n      }\n      (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, value);\n    };\n    _this.handleKeyEvent = function (event) {\n      var altKey = event.altKey,\n        ctrlKey = event.ctrlKey,\n        metaKey = event.metaKey,\n        shiftKey = event.shiftKey;\n      if (event.key === \"Escape\") {\n        _this.cancelEditing();\n        return;\n      }\n      var hasModifierKey = altKey || ctrlKey || metaKey || shiftKey;\n      if (event.key === \"Enter\") {\n        // prevent browsers (Edge?) from full screening with alt + enter\n        // shift + enter adds a newline by default\n        if (altKey || shiftKey) {\n          event.preventDefault();\n        }\n        if (_this.props.confirmOnEnterKey && _this.props.multiline) {\n          if (event.target != null && hasModifierKey) {\n            insertAtCaret(event.target, \"\\n\");\n            _this.handleTextChange(event);\n          } else {\n            _this.toggleEditing();\n          }\n        } else if (!_this.props.multiline || hasModifierKey) {\n          _this.toggleEditing();\n        }\n      }\n    };\n    var value = props.value == null ? props.defaultValue : props.value;\n    _this.state = {\n      inputHeight: 0,\n      inputWidth: 0,\n      isEditing: props.isEditing === true && props.disabled === false,\n      lastValue: value,\n      value: value\n    };\n    return _this;\n  }\n  EditableText.prototype.render = function () {\n    var _a;\n    var _b;\n    var _c = this.props,\n      alwaysRenderInput = _c.alwaysRenderInput,\n      disabled = _c.disabled,\n      elementRef = _c.elementRef,\n      multiline = _c.multiline,\n      contentId = _c.contentId;\n    var value = (_b = this.props.value) !== null && _b !== void 0 ? _b : this.state.value;\n    var hasValue = value != null && value !== \"\";\n    var classes = classNames(Classes.EDITABLE_TEXT, Classes.intentClass(this.props.intent), (_a = {}, _a[Classes.DISABLED] = disabled, _a[Classes.EDITABLE_TEXT_EDITING] = this.state.isEditing, _a[Classes.EDITABLE_TEXT_PLACEHOLDER] = !hasValue, _a[Classes.MULTILINE] = multiline, _a), this.props.className);\n    var contentStyle;\n    if (multiline) {\n      // set height only in multiline mode when not editing\n      // otherwise we're measuring this element to determine appropriate height of text\n      contentStyle = {\n        height: !this.state.isEditing ? this.state.inputHeight : undefined\n      };\n    } else {\n      // minWidth only applies in single line mode (multiline == width 100%)\n      contentStyle = {\n        height: this.state.inputHeight,\n        lineHeight: this.state.inputHeight != null ? \"\".concat(this.state.inputHeight, \"px\") : undefined,\n        minWidth: this.props.minWidth\n      };\n    }\n    // If we are always rendering an input, then NEVER make the container div focusable.\n    // Otherwise, make container div focusable when not editing, so it can still be tabbed\n    // to focus (when the input is rendered, it is itself focusable so container div doesn't need to be)\n    var tabIndex = alwaysRenderInput || this.state.isEditing || disabled ? undefined : 0;\n    // we need the contents to be rendered while editing so that we can measure their height\n    // and size the container element responsively\n    var shouldHideContents = alwaysRenderInput && !this.state.isEditing;\n    var spanProps = contentId != null ? {\n      id: contentId\n    } : {};\n    return React.createElement(\"div\", {\n      className: classes,\n      onFocus: this.handleFocus,\n      tabIndex: tabIndex,\n      ref: elementRef\n    }, alwaysRenderInput || this.state.isEditing ? this.renderInput(value) : undefined, shouldHideContents ? undefined : React.createElement(\"span\", __assign({}, spanProps, {\n      className: Classes.EDITABLE_TEXT_CONTENT,\n      ref: this.refHandlers.content,\n      style: contentStyle\n    }), hasValue ? value : this.props.placeholder));\n  };\n  EditableText.prototype.componentDidMount = function () {\n    this.updateInputDimensions();\n  };\n  EditableText.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var _a, _b;\n    var newState = {};\n    // allow setting the value to undefined/null in controlled mode\n    if (this.props.value !== prevProps.value && (prevProps.value != null || this.props.value != null)) {\n      newState.value = this.props.value;\n    }\n    if (this.props.isEditing != null && this.props.isEditing !== prevProps.isEditing) {\n      newState.isEditing = this.props.isEditing;\n    }\n    if (this.props.disabled || this.props.disabled == null && prevProps.disabled) {\n      newState.isEditing = false;\n    }\n    this.setState(newState);\n    if (this.state.isEditing && !prevState.isEditing) {\n      (_b = (_a = this.props).onEdit) === null || _b === void 0 ? void 0 : _b.call(_a, this.state.value);\n    }\n    // updateInputDimensions is an expensive method. Call it only when the props\n    // it depends on change\n    if (this.state.value !== prevState.value || this.props.alwaysRenderInput !== prevProps.alwaysRenderInput || this.props.maxLines !== prevProps.maxLines || this.props.minLines !== prevProps.minLines || this.props.minWidth !== prevProps.minWidth || this.props.multiline !== prevProps.multiline) {\n      this.updateInputDimensions();\n    }\n  };\n  EditableText.prototype.renderInput = function (value) {\n    var _a = this.props,\n      disabled = _a.disabled,\n      maxLength = _a.maxLength,\n      multiline = _a.multiline,\n      type = _a.type,\n      placeholder = _a.placeholder;\n    var props = {\n      className: Classes.EDITABLE_TEXT_INPUT,\n      disabled: disabled,\n      maxLength: maxLength,\n      onBlur: this.toggleEditing,\n      onChange: this.handleTextChange,\n      onKeyDown: this.handleKeyEvent,\n      placeholder: placeholder,\n      value: value\n    };\n    var _b = this.state,\n      inputHeight = _b.inputHeight,\n      inputWidth = _b.inputWidth;\n    if (inputHeight !== 0 && inputWidth !== 0) {\n      props.style = {\n        height: inputHeight,\n        lineHeight: !multiline && inputHeight != null ? \"\".concat(inputHeight, \"px\") : undefined,\n        width: multiline ? \"100%\" : inputWidth\n      };\n    }\n    return multiline ? React.createElement(\"textarea\", __assign({\n      ref: this.refHandlers.input\n    }, props)) : React.createElement(\"input\", __assign({\n      ref: this.refHandlers.input,\n      type: type\n    }, props));\n  };\n  EditableText.prototype.updateInputDimensions = function () {\n    if (this.valueElement != null) {\n      var _a = this.props,\n        maxLines = _a.maxLines,\n        minLines = _a.minLines,\n        minWidth = _a.minWidth,\n        multiline = _a.multiline;\n      var _b = this.valueElement,\n        parentElement_1 = _b.parentElement,\n        textContent = _b.textContent;\n      var _c = this.valueElement,\n        scrollHeight_1 = _c.scrollHeight,\n        scrollWidth = _c.scrollWidth;\n      var lineHeight = getLineHeight(this.valueElement);\n      // add one line to computed <span> height if text ends in newline\n      // because <span> collapses that trailing whitespace but <textarea> shows it\n      if (multiline && this.state.isEditing && /\\n$/.test(textContent !== null && textContent !== void 0 ? textContent : \"\")) {\n        scrollHeight_1 += lineHeight;\n      }\n      if (lineHeight > 0) {\n        // line height could be 0 if the isNaN block from getLineHeight kicks in\n        scrollHeight_1 = clamp(scrollHeight_1, minLines * lineHeight, maxLines * lineHeight);\n      }\n      // Chrome's input caret height misaligns text so the line-height must be larger than font-size.\n      // The computed scrollHeight must also account for a larger inherited line-height from the parent.\n      scrollHeight_1 = Math.max(scrollHeight_1, getFontSize(this.valueElement) + 1, getLineHeight(parentElement_1));\n      // Need to add a small buffer so text does not shift prior to resizing, causing an infinite loop.\n      scrollWidth += BUFFER_WIDTH_DEFAULT;\n      this.setState({\n        inputHeight: scrollHeight_1,\n        inputWidth: Math.max(scrollWidth, minWidth)\n      });\n      // synchronizes the ::before pseudo-element's height while editing for Chrome 53\n      if (multiline && this.state.isEditing) {\n        this.setTimeout(function () {\n          return parentElement_1.style.height = \"\".concat(scrollHeight_1, \"px\");\n        });\n      }\n    }\n  };\n  EditableText.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".EditableText\");\n  EditableText.defaultProps = {\n    alwaysRenderInput: false,\n    confirmOnEnterKey: false,\n    defaultValue: \"\",\n    disabled: false,\n    maxLines: Infinity,\n    minLines: 1,\n    minWidth: 80,\n    multiline: false,\n    placeholder: \"Click to Edit\",\n    type: \"text\"\n  };\n  return EditableText;\n}(AbstractPureComponent);\nexport { EditableText };\nfunction getFontSize(element) {\n  var fontSize = getComputedStyle(element).fontSize;\n  return fontSize === \"\" ? 0 : parseInt(fontSize.slice(0, -2), 10);\n}\nfunction getLineHeight(element) {\n  // getComputedStyle() => 18.0001px => 18\n  var lineHeight = parseInt(getComputedStyle(element).lineHeight.slice(0, -2), 10);\n  // this check will be true if line-height is a keyword like \"normal\"\n  if (isNaN(lineHeight)) {\n    // @see http://stackoverflow.com/a/18430767/6342931\n    var line = document.createElement(\"span\");\n    line.innerHTML = \"<br>\";\n    element.appendChild(line);\n    var singleLineHeight = element.offsetHeight;\n    line.innerHTML = \"<br><br>\";\n    var doubleLineHeight = element.offsetHeight;\n    element.removeChild(line);\n    // this can return 0 in edge cases\n    lineHeight = doubleLineHeight - singleLineHeight;\n  }\n  return lineHeight;\n}\nfunction insertAtCaret(el, text) {\n  var selectionEnd = el.selectionEnd,\n    selectionStart = el.selectionStart,\n    value = el.value;\n  if (selectionStart >= 0) {\n    var before_1 = value.substring(0, selectionStart);\n    var after_1 = value.substring(selectionEnd, value.length);\n    var len = text.length;\n    el.value = \"\".concat(before_1).concat(text).concat(after_1);\n    el.selectionStart = selectionStart + len;\n    el.selectionEnd = selectionStart + len;\n  }\n}\nfunction inputSupportsSelection(input) {\n  switch (input.type) {\n    // HTMLTextAreaElement\n    case \"textarea\":\n      return true;\n    // HTMLInputElement\n    // see https://html.spec.whatwg.org/multipage/input.html#do-not-apply\n    case \"text\":\n    case \"search\":\n    case \"tel\":\n    case \"url\":\n    case \"password\":\n      return true;\n    default:\n      return false;\n  }\n}","map":{"version":3,"names":["classNames","React","AbstractPureComponent","Classes","DISPLAYNAME_PREFIX","clamp","BUFFER_WIDTH_DEFAULT","EditableText","_super","__extends","props","_this","call","inputElement","valueElement","refHandlers","content","spanElement","input","alwaysRenderInput","focus","state","isEditing","supportsSelection","inputSupportsSelection","length_1","value","length","setSelectionRange","selectAllOnFocus","scrollLeft","scrollWidth","cancelEditing","_e","lastValue","setState","_b","_a","onChange","_d","_c","onCancel","toggleEditing","onConfirm","disabled","handleFocus","length_2","handleTextChange","event","target","handleKeyEvent","altKey","ctrlKey","metaKey","shiftKey","key","hasModifierKey","preventDefault","confirmOnEnterKey","multiline","insertAtCaret","defaultValue","inputHeight","inputWidth","prototype","render","elementRef","contentId","hasValue","classes","EDITABLE_TEXT","intentClass","intent","DISABLED","EDITABLE_TEXT_EDITING","EDITABLE_TEXT_PLACEHOLDER","MULTILINE","className","contentStyle","height","undefined","lineHeight","concat","minWidth","tabIndex","shouldHideContents","spanProps","id","createElement","onFocus","ref","renderInput","__assign","EDITABLE_TEXT_CONTENT","style","placeholder","componentDidMount","updateInputDimensions","componentDidUpdate","prevProps","prevState","newState","onEdit","maxLines","minLines","maxLength","type","EDITABLE_TEXT_INPUT","onBlur","onKeyDown","width","parentElement_1","parentElement","textContent","scrollHeight_1","scrollHeight","getLineHeight","test","Math","max","getFontSize","setTimeout","displayName","defaultProps","Infinity","element","fontSize","getComputedStyle","parseInt","slice","isNaN","line","document","innerHTML","appendChild","singleLineHeight","offsetHeight","doubleLineHeight","removeChild","el","text","selectionEnd","selectionStart","before_1","substring","after_1","len"],"sources":["/home/meander/Desktop/Akash/Workit/my-app/node_modules/@blueprintjs/core/src/components/editable-text/editableText.tsx"],"sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport { AbstractPureComponent, Classes } from \"../../common\";\nimport { DISPLAYNAME_PREFIX, IntentProps, Props } from \"../../common/props\";\nimport { clamp } from \"../../common/utils\";\n\nexport interface EditableTextProps extends IntentProps, Props {\n    /**\n     * EXPERIMENTAL FEATURE.\n     *\n     * When true, this forces the component to _always_ render an editable input (or textarea)\n     * both when the component is focussed and unfocussed, instead of the component's default\n     * behavior of switching between a text span and a text input upon interaction.\n     *\n     * This behavior can help in certain applications where, for example, a custom right-click\n     * context menu is used to supply clipboard copy and paste functionality.\n     *\n     * @default false\n     */\n    alwaysRenderInput?: boolean;\n\n    /**\n     * If `true` and in multiline mode, the `enter` key will trigger onConfirm and `mod+enter`\n     * will insert a newline. If `false`, the key bindings are inverted such that `enter`\n     * adds a newline.\n     *\n     * @default false\n     */\n    confirmOnEnterKey?: boolean;\n\n    /** Default text value of uncontrolled input. */\n    defaultValue?: string;\n\n    /**\n     * Whether the text can be edited.\n     *\n     * @default false\n     */\n    disabled?: boolean;\n\n    /**\n     * Ref to attach to the root element rendered by this component.\n     *\n     * N.B. this may be renamed to simply `ref` in a future major version of Blueprint, when this class component is\n     * refactored into a function.\n     */\n    elementRef?: React.Ref<HTMLDivElement>;\n\n    /** Whether the component is currently being edited. */\n    isEditing?: boolean;\n\n    /** Maximum number of characters allowed. Unlimited by default. */\n    maxLength?: number;\n\n    /** Minimum width in pixels of the input, when not `multiline`. */\n    minWidth?: number;\n\n    /**\n     * Whether the component supports multiple lines of text.\n     * This prop should not be changed during the component's lifetime.\n     *\n     * @default false\n     */\n    multiline?: boolean;\n\n    /**\n     * Maximum number of lines before scrolling begins, when `multiline`.\n     */\n    maxLines?: number;\n\n    /**\n     * Minimum number of lines (essentially minimum height), when `multiline`.\n     *\n     * @default 1\n     */\n    minLines?: number;\n\n    /**\n     * Placeholder text when there is no value.\n     *\n     * @default \"Click to Edit\"\n     */\n    placeholder?: string;\n\n    /**\n     * Whether the entire text field should be selected on focus.\n     * If `false`, the cursor is placed at the end of the text.\n     * This prop is ignored on inputs with type other then text, search, url, tel and password. See https://html.spec.whatwg.org/multipage/input.html#do-not-apply for details.\n     *\n     * @default false\n     */\n    selectAllOnFocus?: boolean;\n\n    /**\n     * The type of input that should be shown, when not `multiline`.\n     */\n    type?: string;\n\n    /** Text value of controlled input. */\n    value?: string;\n\n    /** ID attribute to pass to the underlying element that contains the text contents. This allows for referencing via aria attributes */\n    contentId?: string;\n\n    /** Callback invoked when user cancels input with the `esc` key. Receives last confirmed value. */\n    onCancel?(value: string): void;\n\n    /** Callback invoked when user changes input in any way. */\n    onChange?(value: string): void;\n\n    /** Callback invoked when user confirms value with `enter` key or by blurring input. */\n    onConfirm?(value: string): void;\n\n    /** Callback invoked after the user enters edit mode. */\n    onEdit?(value: string | undefined): void;\n}\n\nexport interface EditableTextState {\n    /** Pixel height of the input, measured from span size */\n    inputHeight?: number;\n    /** Pixel width of the input, measured from span size */\n    inputWidth?: number;\n    /** Whether the value is currently being edited */\n    isEditing?: boolean;\n    /** The last confirmed value */\n    lastValue?: string;\n    /** The controlled input value, may be different from prop during editing */\n    value?: string;\n}\n\nconst BUFFER_WIDTH_DEFAULT = 5;\n\n/**\n * EditableText component.\n *\n * @see https://blueprintjs.com/docs/#core/components/editable-text\n */\nexport class EditableText extends AbstractPureComponent<EditableTextProps, EditableTextState> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.EditableText`;\n\n    public static defaultProps: EditableTextProps = {\n        alwaysRenderInput: false,\n        confirmOnEnterKey: false,\n        defaultValue: \"\",\n        disabled: false,\n        maxLines: Infinity,\n        minLines: 1,\n        minWidth: 80,\n        multiline: false,\n        placeholder: \"Click to Edit\",\n        type: \"text\",\n    };\n\n    private inputElement: HTMLInputElement | HTMLTextAreaElement | null = null;\n\n    private valueElement: HTMLSpanElement | null = null;\n\n    private refHandlers = {\n        content: (spanElement: HTMLSpanElement | null) => {\n            this.valueElement = spanElement;\n        },\n        input: (input: HTMLInputElement | HTMLTextAreaElement | null) => {\n            if (input != null) {\n                this.inputElement = input;\n\n                // temporary fix for #3882\n                if (!this.props.alwaysRenderInput) {\n                    this.inputElement.focus();\n                }\n\n                if (this.state != null && this.state.isEditing) {\n                    const supportsSelection = inputSupportsSelection(input);\n                    if (supportsSelection) {\n                        const { length } = input.value;\n                        input.setSelectionRange(this.props.selectAllOnFocus ? 0 : length, length);\n                    }\n                    if (!supportsSelection || !this.props.selectAllOnFocus) {\n                        input.scrollLeft = input.scrollWidth;\n                    }\n                }\n            }\n        },\n    };\n\n    public constructor(props: EditableTextProps) {\n        super(props);\n\n        const value = props.value == null ? props.defaultValue : props.value;\n        this.state = {\n            inputHeight: 0,\n            inputWidth: 0,\n            isEditing: props.isEditing === true && props.disabled === false,\n            lastValue: value,\n            value,\n        };\n    }\n\n    public render() {\n        const { alwaysRenderInput, disabled, elementRef, multiline, contentId } = this.props;\n        const value = this.props.value ?? this.state.value;\n        const hasValue = value != null && value !== \"\";\n\n        const classes = classNames(\n            Classes.EDITABLE_TEXT,\n            Classes.intentClass(this.props.intent),\n            {\n                [Classes.DISABLED]: disabled,\n                [Classes.EDITABLE_TEXT_EDITING]: this.state.isEditing,\n                [Classes.EDITABLE_TEXT_PLACEHOLDER]: !hasValue,\n                [Classes.MULTILINE]: multiline,\n            },\n            this.props.className,\n        );\n\n        let contentStyle: React.CSSProperties;\n        if (multiline) {\n            // set height only in multiline mode when not editing\n            // otherwise we're measuring this element to determine appropriate height of text\n            contentStyle = { height: !this.state.isEditing ? this.state.inputHeight : undefined };\n        } else {\n            // minWidth only applies in single line mode (multiline == width 100%)\n            contentStyle = {\n                height: this.state.inputHeight,\n                lineHeight: this.state.inputHeight != null ? `${this.state.inputHeight}px` : undefined,\n                minWidth: this.props.minWidth,\n            };\n        }\n\n        // If we are always rendering an input, then NEVER make the container div focusable.\n        // Otherwise, make container div focusable when not editing, so it can still be tabbed\n        // to focus (when the input is rendered, it is itself focusable so container div doesn't need to be)\n        const tabIndex = alwaysRenderInput || this.state.isEditing || disabled ? undefined : 0;\n\n        // we need the contents to be rendered while editing so that we can measure their height\n        // and size the container element responsively\n        const shouldHideContents = alwaysRenderInput && !this.state.isEditing;\n\n        const spanProps: React.HTMLProps<HTMLSpanElement> = contentId != null ? { id: contentId } : {};\n\n        return (\n            <div className={classes} onFocus={this.handleFocus} tabIndex={tabIndex} ref={elementRef}>\n                {alwaysRenderInput || this.state.isEditing ? this.renderInput(value) : undefined}\n                {shouldHideContents ? undefined : (\n                    <span\n                        {...spanProps}\n                        className={Classes.EDITABLE_TEXT_CONTENT}\n                        ref={this.refHandlers.content}\n                        style={contentStyle}\n                    >\n                        {hasValue ? value : this.props.placeholder}\n                    </span>\n                )}\n            </div>\n        );\n    }\n\n    public componentDidMount() {\n        this.updateInputDimensions();\n    }\n\n    public componentDidUpdate(prevProps: EditableTextProps, prevState: EditableTextState) {\n        const newState: EditableTextState = {};\n        // allow setting the value to undefined/null in controlled mode\n        if (this.props.value !== prevProps.value && (prevProps.value != null || this.props.value != null)) {\n            newState.value = this.props.value;\n        }\n        if (this.props.isEditing != null && this.props.isEditing !== prevProps.isEditing) {\n            newState.isEditing = this.props.isEditing;\n        }\n        if (this.props.disabled || (this.props.disabled == null && prevProps.disabled)) {\n            newState.isEditing = false;\n        }\n\n        this.setState(newState);\n\n        if (this.state.isEditing && !prevState.isEditing) {\n            this.props.onEdit?.(this.state.value);\n        }\n        // updateInputDimensions is an expensive method. Call it only when the props\n        // it depends on change\n        if (\n            this.state.value !== prevState.value ||\n            this.props.alwaysRenderInput !== prevProps.alwaysRenderInput ||\n            this.props.maxLines !== prevProps.maxLines ||\n            this.props.minLines !== prevProps.minLines ||\n            this.props.minWidth !== prevProps.minWidth ||\n            this.props.multiline !== prevProps.multiline\n        ) {\n            this.updateInputDimensions();\n        }\n    }\n\n    public cancelEditing = () => {\n        const { lastValue, value } = this.state;\n        this.setState({ isEditing: false, value: lastValue });\n        if (value !== lastValue) {\n            this.props.onChange?.(lastValue!);\n        }\n        this.props.onCancel?.(lastValue!);\n    };\n\n    public toggleEditing = () => {\n        if (this.state.isEditing) {\n            const { value } = this.state;\n            this.setState({ isEditing: false, lastValue: value });\n            this.props.onConfirm?.(value!);\n        } else if (!this.props.disabled) {\n            this.setState({ isEditing: true });\n        }\n    };\n\n    private handleFocus = () => {\n        const { alwaysRenderInput, disabled, selectAllOnFocus } = this.props;\n\n        if (!disabled) {\n            this.setState({ isEditing: true });\n        }\n\n        if (alwaysRenderInput && selectAllOnFocus && this.inputElement != null) {\n            const { length } = this.inputElement.value;\n            this.inputElement.setSelectionRange(0, length);\n        }\n    };\n\n    private handleTextChange = (event: React.FormEvent<HTMLElement>) => {\n        const value = (event.target as HTMLInputElement).value;\n        // state value should be updated only when uncontrolled\n        if (this.props.value == null) {\n            this.setState({ value });\n        }\n        this.props.onChange?.(value);\n    };\n\n    private handleKeyEvent = (event: React.KeyboardEvent<HTMLElement>) => {\n        const { altKey, ctrlKey, metaKey, shiftKey } = event;\n        if (event.key === \"Escape\") {\n            this.cancelEditing();\n            return;\n        }\n\n        const hasModifierKey = altKey || ctrlKey || metaKey || shiftKey;\n        if (event.key === \"Enter\") {\n            // prevent browsers (Edge?) from full screening with alt + enter\n            // shift + enter adds a newline by default\n            if (altKey || shiftKey) {\n                event.preventDefault();\n            }\n\n            if (this.props.confirmOnEnterKey && this.props.multiline) {\n                if (event.target != null && hasModifierKey) {\n                    insertAtCaret(event.target as HTMLTextAreaElement, \"\\n\");\n                    this.handleTextChange(event);\n                } else {\n                    this.toggleEditing();\n                }\n            } else if (!this.props.multiline || hasModifierKey) {\n                this.toggleEditing();\n            }\n        }\n    };\n\n    private renderInput(value: string | undefined) {\n        const { disabled, maxLength, multiline, type, placeholder } = this.props;\n        const props: React.InputHTMLAttributes<HTMLInputElement | HTMLTextAreaElement> = {\n            className: Classes.EDITABLE_TEXT_INPUT,\n            disabled,\n            maxLength,\n            onBlur: this.toggleEditing,\n            onChange: this.handleTextChange,\n            onKeyDown: this.handleKeyEvent,\n            placeholder,\n            value,\n        };\n\n        const { inputHeight, inputWidth } = this.state;\n        if (inputHeight !== 0 && inputWidth !== 0) {\n            props.style = {\n                height: inputHeight,\n                lineHeight: !multiline && inputHeight != null ? `${inputHeight}px` : undefined,\n                width: multiline ? \"100%\" : inputWidth,\n            };\n        }\n\n        return multiline ? (\n            <textarea ref={this.refHandlers.input} {...props} />\n        ) : (\n            <input ref={this.refHandlers.input} type={type} {...props} />\n        );\n    }\n\n    private updateInputDimensions() {\n        if (this.valueElement != null) {\n            const { maxLines, minLines, minWidth, multiline } = this.props;\n            const { parentElement, textContent } = this.valueElement;\n            let { scrollHeight, scrollWidth } = this.valueElement;\n            const lineHeight = getLineHeight(this.valueElement);\n            // add one line to computed <span> height if text ends in newline\n            // because <span> collapses that trailing whitespace but <textarea> shows it\n            if (multiline && this.state.isEditing && /\\n$/.test(textContent ?? \"\")) {\n                scrollHeight += lineHeight;\n            }\n            if (lineHeight > 0) {\n                // line height could be 0 if the isNaN block from getLineHeight kicks in\n                scrollHeight = clamp(scrollHeight, minLines! * lineHeight, maxLines! * lineHeight);\n            }\n            // Chrome's input caret height misaligns text so the line-height must be larger than font-size.\n            // The computed scrollHeight must also account for a larger inherited line-height from the parent.\n            scrollHeight = Math.max(scrollHeight, getFontSize(this.valueElement) + 1, getLineHeight(parentElement!));\n            // Need to add a small buffer so text does not shift prior to resizing, causing an infinite loop.\n            scrollWidth += BUFFER_WIDTH_DEFAULT;\n\n            this.setState({\n                inputHeight: scrollHeight,\n                inputWidth: Math.max(scrollWidth, minWidth!),\n            });\n            // synchronizes the ::before pseudo-element's height while editing for Chrome 53\n            if (multiline && this.state.isEditing) {\n                this.setTimeout(() => (parentElement!.style.height = `${scrollHeight}px`));\n            }\n        }\n    }\n}\n\nfunction getFontSize(element: HTMLElement) {\n    const fontSize = getComputedStyle(element).fontSize;\n    return fontSize === \"\" ? 0 : parseInt(fontSize.slice(0, -2), 10);\n}\n\nfunction getLineHeight(element: HTMLElement) {\n    // getComputedStyle() => 18.0001px => 18\n    let lineHeight = parseInt(getComputedStyle(element).lineHeight.slice(0, -2), 10);\n    // this check will be true if line-height is a keyword like \"normal\"\n    if (isNaN(lineHeight)) {\n        // @see http://stackoverflow.com/a/18430767/6342931\n        const line = document.createElement(\"span\");\n        line.innerHTML = \"<br>\";\n        element.appendChild(line);\n        const singleLineHeight = element.offsetHeight;\n        line.innerHTML = \"<br><br>\";\n        const doubleLineHeight = element.offsetHeight;\n        element.removeChild(line);\n        // this can return 0 in edge cases\n        lineHeight = doubleLineHeight - singleLineHeight;\n    }\n    return lineHeight;\n}\n\nfunction insertAtCaret(el: HTMLTextAreaElement, text: string) {\n    const { selectionEnd, selectionStart, value } = el;\n    if (selectionStart >= 0) {\n        const before = value.substring(0, selectionStart);\n        const after = value.substring(selectionEnd, value.length);\n        const len = text.length;\n        el.value = `${before}${text}${after}`;\n        el.selectionStart = selectionStart + len;\n        el.selectionEnd = selectionStart + len;\n    }\n}\n\nfunction inputSupportsSelection(input: HTMLInputElement | HTMLTextAreaElement) {\n    switch (input.type) {\n        // HTMLTextAreaElement\n        case \"textarea\":\n            return true;\n        // HTMLInputElement\n        // see https://html.spec.whatwg.org/multipage/input.html#do-not-apply\n        case \"text\":\n        case \"search\":\n        case \"tel\":\n        case \"url\":\n        case \"password\":\n            return true;\n        default:\n            return false;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}