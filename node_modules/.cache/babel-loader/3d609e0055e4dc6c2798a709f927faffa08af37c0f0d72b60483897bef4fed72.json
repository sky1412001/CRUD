{"ast":null,"code":"/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { Boundary, Classes, DISPLAYNAME_PREFIX } from \"../../common\";\nimport { OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED } from \"../../common/errors\";\nimport { shallowCompareKeys } from \"../../common/utils\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\";\n/**\n * Overflow list component.\n *\n * @see https://blueprintjs.com/docs/#core/components/overflow-list\n */\nvar OverflowList = /** @class */function (_super) {\n  __extends(OverflowList, _super);\n  function OverflowList() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.state = {\n      chopSize: _this.defaultChopSize(),\n      lastChopSize: null,\n      lastOverflowCount: 0,\n      overflow: [],\n      repartitioning: false,\n      visible: _this.props.items\n    };\n    _this.spacer = null;\n    _this.resize = function () {\n      _this.repartition();\n    };\n    return _this;\n  }\n  OverflowList.ofType = function () {\n    return OverflowList;\n  };\n  OverflowList.prototype.componentDidMount = function () {\n    this.repartition();\n  };\n  OverflowList.prototype.shouldComponentUpdate = function (nextProps, nextState) {\n    // We want this component to always re-render, even when props haven't changed, so that\n    // changes in the renderers' behavior can be reflected.\n    // The following statement prevents re-rendering only in the case where the state changes\n    // identity (i.e. setState was called), but the state is still the same when\n    // shallow-compared to the previous state. Original context: https://github.com/palantir/blueprint/pull/3278.\n    // We also ensure that we re-render if the props DO change (which isn't necessarily accounted for by other logic).\n    return this.props !== nextProps || !(this.state !== nextState && shallowCompareKeys(this.state, nextState));\n  };\n  OverflowList.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var _a, _b;\n    if (prevProps.observeParents !== this.props.observeParents) {\n      console.warn(OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED);\n    }\n    if (prevProps.collapseFrom !== this.props.collapseFrom || prevProps.items !== this.props.items || prevProps.minVisibleItems !== this.props.minVisibleItems || prevProps.overflowRenderer !== this.props.overflowRenderer || prevProps.alwaysRenderOverflow !== this.props.alwaysRenderOverflow || prevProps.visibleItemRenderer !== this.props.visibleItemRenderer) {\n      // reset visible state if the above props change.\n      this.setState({\n        chopSize: this.defaultChopSize(),\n        lastChopSize: null,\n        lastOverflowCount: 0,\n        overflow: [],\n        repartitioning: true,\n        visible: this.props.items\n      });\n    }\n    var _c = this.state,\n      repartitioning = _c.repartitioning,\n      overflow = _c.overflow,\n      lastOverflowCount = _c.lastOverflowCount;\n    if (\n    // if a resize operation has just completed\n    repartitioning === false && prevState.repartitioning === true) {\n      // only invoke the callback if the UI has actually changed\n      if (overflow.length !== lastOverflowCount) {\n        (_b = (_a = this.props).onOverflow) === null || _b === void 0 ? void 0 : _b.call(_a, overflow.slice());\n      }\n    } else if (!shallowCompareKeys(prevState, this.state)) {\n      this.repartition();\n    }\n  };\n  OverflowList.prototype.render = function () {\n    var _this = this;\n    var _a = this.props,\n      className = _a.className,\n      collapseFrom = _a.collapseFrom,\n      observeParents = _a.observeParents,\n      style = _a.style,\n      _b = _a.tagName,\n      tagName = _b === void 0 ? \"div\" : _b,\n      visibleItemRenderer = _a.visibleItemRenderer;\n    var overflow = this.maybeRenderOverflow();\n    var list = React.createElement(tagName, {\n      className: classNames(Classes.OVERFLOW_LIST, className),\n      style: style\n    }, collapseFrom === Boundary.START ? overflow : null, this.state.visible.map(visibleItemRenderer), collapseFrom === Boundary.END ? overflow : null, React.createElement(\"div\", {\n      className: Classes.OVERFLOW_LIST_SPACER,\n      ref: function (ref) {\n        return _this.spacer = ref;\n      }\n    }));\n    return React.createElement(ResizeSensor, {\n      onResize: this.resize,\n      observeParents: observeParents\n    }, list);\n  };\n  OverflowList.prototype.maybeRenderOverflow = function () {\n    var overflow = this.state.overflow;\n    if (overflow.length === 0 && !this.props.alwaysRenderOverflow) {\n      return null;\n    }\n    return this.props.overflowRenderer(overflow.slice());\n  };\n  OverflowList.prototype.repartition = function () {\n    var _this = this;\n    var _a;\n    if (this.spacer == null) {\n      return;\n    }\n    // if lastChopSize was 1, then our binary search has exhausted.\n    var partitionExhausted = this.state.lastChopSize === 1;\n    var minVisible = (_a = this.props.minVisibleItems) !== null && _a !== void 0 ? _a : 0;\n    // spacer has flex-shrink and width 1px so if it's much smaller then we know to shrink\n    var shouldShrink = this.spacer.offsetWidth < 0.9 && this.state.visible.length > minVisible;\n    // we only check partitionExhausted for shouldGrow to ensure shrinking is the final operation.\n    var shouldGrow = (this.spacer.offsetWidth >= 1 || this.state.visible.length < minVisible) && this.state.overflow.length > 0 && !partitionExhausted;\n    if (shouldShrink || shouldGrow) {\n      this.setState(function (state) {\n        var visible;\n        var overflow;\n        if (_this.props.collapseFrom === Boundary.END) {\n          var result = shiftElements(state.visible, state.overflow, _this.state.chopSize * (shouldShrink ? 1 : -1));\n          visible = result[0];\n          overflow = result[1];\n        } else {\n          var result = shiftElements(state.overflow, state.visible, _this.state.chopSize * (shouldShrink ? -1 : 1));\n          overflow = result[0];\n          visible = result[1];\n        }\n        return {\n          chopSize: halve(state.chopSize),\n          lastChopSize: state.chopSize,\n          // if we're starting a new partition cycle, record the last overflow count so we can track whether the UI changes after the new overflow is calculated\n          lastOverflowCount: _this.isFirstPartitionCycle(state.chopSize) ? state.overflow.length : state.lastOverflowCount,\n          overflow: overflow,\n          repartitioning: true,\n          visible: visible\n        };\n      });\n    } else {\n      // repartition complete!\n      this.setState({\n        chopSize: this.defaultChopSize(),\n        lastChopSize: null,\n        repartitioning: false\n      });\n    }\n  };\n  OverflowList.prototype.defaultChopSize = function () {\n    return halve(this.props.items.length);\n  };\n  OverflowList.prototype.isFirstPartitionCycle = function (currentChopSize) {\n    return currentChopSize === this.defaultChopSize();\n  };\n  OverflowList.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".OverflowList\");\n  OverflowList.defaultProps = {\n    alwaysRenderOverflow: false,\n    collapseFrom: Boundary.START,\n    minVisibleItems: 0\n  };\n  return OverflowList;\n}(React.Component);\nexport { OverflowList };\nfunction halve(num) {\n  return Math.ceil(num / 2);\n}\nfunction shiftElements(leftArray, rightArray, num) {\n  // if num is positive then elements are shifted from left-to-right, if negative then right-to-left\n  var allElements = leftArray.concat(rightArray);\n  var newLeftLength = leftArray.length - num;\n  if (newLeftLength <= 0) {\n    return [[], allElements];\n  } else if (newLeftLength >= allElements.length) {\n    return [allElements, []];\n  }\n  var sliceIndex = allElements.length - newLeftLength;\n  return [allElements.slice(0, -sliceIndex), allElements.slice(-sliceIndex)];\n}","map":{"version":3,"names":["classNames","React","Boundary","Classes","DISPLAYNAME_PREFIX","OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED","shallowCompareKeys","ResizeSensor","OverflowList","_super","__extends","_this","apply","arguments","state","chopSize","defaultChopSize","lastChopSize","lastOverflowCount","overflow","repartitioning","visible","props","items","spacer","resize","repartition","ofType","prototype","componentDidMount","shouldComponentUpdate","nextProps","nextState","componentDidUpdate","prevProps","prevState","observeParents","console","warn","collapseFrom","minVisibleItems","overflowRenderer","alwaysRenderOverflow","visibleItemRenderer","setState","_c","length","_b","_a","onOverflow","call","slice","render","className","style","tagName","maybeRenderOverflow","list","createElement","OVERFLOW_LIST","START","map","END","OVERFLOW_LIST_SPACER","ref","onResize","partitionExhausted","minVisible","shouldShrink","offsetWidth","shouldGrow","result","shiftElements","halve","isFirstPartitionCycle","currentChopSize","displayName","concat","defaultProps","Component","num","Math","ceil","leftArray","rightArray","allElements","newLeftLength","sliceIndex"],"sources":["/home/meander/Desktop/Akash/Workit/my-app/node_modules/@blueprintjs/core/src/components/overflow-list/overflowList.tsx"],"sourcesContent":["/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport { Boundary, Classes, DISPLAYNAME_PREFIX, Props } from \"../../common\";\nimport { OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED } from \"../../common/errors\";\nimport { shallowCompareKeys } from \"../../common/utils\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\";\n\nexport interface OverflowListProps<T> extends Props {\n    /**\n     * Whether to force the overflowRenderer to always be called, even if there are zero items\n     * overflowing. This may be useful, for example, if your overflow renderer contains a Popover\n     * which you do not want to close as the list is resized.\n     *\n     * @default false\n     */\n    alwaysRenderOverflow?: boolean;\n\n    /**\n     * Which direction the items should collapse from: start or end of the\n     * children. This also determines whether `overflowRenderer` appears before\n     * (`START`) or after (`END`) the visible items.\n     *\n     * @default Boundary.START\n     */\n    collapseFrom?: Boundary;\n\n    /**\n     * All items to display in the list. Items that do not fit in the container\n     * will be rendered in the overflow instead.\n     */\n    items: readonly T[];\n\n    /**\n     * The minimum number of visible items that should never collapse into the\n     * overflow menu, regardless of DOM dimensions.\n     *\n     * @default 0\n     */\n    minVisibleItems?: number;\n\n    /**\n     * If `true`, all parent DOM elements of the container will also be\n     * observed. If changes to a parent's size is detected, the overflow will be\n     * recalculated.\n     *\n     * Only enable this prop if the overflow should be recalculated when a\n     * parent element resizes in a way that does not also cause the\n     * `OverflowList` to resize.\n     *\n     * @default false\n     */\n    observeParents?: boolean;\n\n    /**\n     * Callback invoked when the overflowed items change. This is called once\n     * after the DOM has settled, rather that on every intermediate change. It\n     * is not invoked if resizing produces an unchanged overflow state.\n     */\n    onOverflow?: (overflowItems: T[]) => void;\n\n    /**\n     * Callback invoked to render the overflowed items. Unlike\n     * `visibleItemRenderer`, this prop is invoked once with all items that do\n     * not fit in the container.\n     *\n     * Typical use cases for this prop will put overflowed items in a dropdown\n     * menu or display a \"+X items\" label.\n     */\n    overflowRenderer: (overflowItems: T[]) => React.ReactNode;\n\n    /** CSS properties to apply to the root element. */\n    style?: React.CSSProperties;\n\n    /**\n     * HTML tag name for the container element.\n     *\n     * @default \"div\"\n     */\n    tagName?: keyof JSX.IntrinsicElements;\n\n    /**\n     * Callback invoked to render each visible item.\n     * Remember to set a `key` on the rendered element!\n     */\n    visibleItemRenderer: (item: T, index: number) => React.ReactChild;\n}\n\nexport interface OverflowListState<T> {\n    /** Whether repartitioning is still active. An overflow can take several frames to settle. */\n    repartitioning: boolean;\n    /** Length of last overflow to dedupe `onOverflow` calls during smooth resizing. */\n    lastOverflowCount: number;\n    overflow: readonly T[];\n    visible: readonly T[];\n    /** Pointer for the binary search algorithm used to find the finished non-overflowing state */\n    chopSize: number;\n    lastChopSize: number | null;\n}\n\n/**\n * Overflow list component.\n *\n * @see https://blueprintjs.com/docs/#core/components/overflow-list\n */\nexport class OverflowList<T> extends React.Component<OverflowListProps<T>, OverflowListState<T>> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.OverflowList`;\n\n    public static defaultProps: Partial<OverflowListProps<any>> = {\n        alwaysRenderOverflow: false,\n        collapseFrom: Boundary.START,\n        minVisibleItems: 0,\n    };\n\n    public static ofType<U>() {\n        return OverflowList as new (props: OverflowListProps<U>) => OverflowList<U>;\n    }\n\n    public state: OverflowListState<T> = {\n        chopSize: this.defaultChopSize(),\n        lastChopSize: null,\n        lastOverflowCount: 0,\n        overflow: [],\n        repartitioning: false,\n        visible: this.props.items,\n    };\n\n    private spacer: HTMLElement | null = null;\n\n    public componentDidMount() {\n        this.repartition();\n    }\n\n    public shouldComponentUpdate(nextProps: OverflowListProps<T>, nextState: OverflowListState<T>) {\n        // We want this component to always re-render, even when props haven't changed, so that\n        // changes in the renderers' behavior can be reflected.\n        // The following statement prevents re-rendering only in the case where the state changes\n        // identity (i.e. setState was called), but the state is still the same when\n        // shallow-compared to the previous state. Original context: https://github.com/palantir/blueprint/pull/3278.\n        // We also ensure that we re-render if the props DO change (which isn't necessarily accounted for by other logic).\n        return this.props !== nextProps || !(this.state !== nextState && shallowCompareKeys(this.state, nextState));\n    }\n\n    public componentDidUpdate(prevProps: OverflowListProps<T>, prevState: OverflowListState<T>) {\n        if (prevProps.observeParents !== this.props.observeParents) {\n            console.warn(OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED);\n        }\n\n        if (\n            prevProps.collapseFrom !== this.props.collapseFrom ||\n            prevProps.items !== this.props.items ||\n            prevProps.minVisibleItems !== this.props.minVisibleItems ||\n            prevProps.overflowRenderer !== this.props.overflowRenderer ||\n            prevProps.alwaysRenderOverflow !== this.props.alwaysRenderOverflow ||\n            prevProps.visibleItemRenderer !== this.props.visibleItemRenderer\n        ) {\n            // reset visible state if the above props change.\n            this.setState({\n                chopSize: this.defaultChopSize(),\n                lastChopSize: null,\n                lastOverflowCount: 0,\n                overflow: [],\n                repartitioning: true,\n                visible: this.props.items,\n            });\n        }\n\n        const { repartitioning, overflow, lastOverflowCount } = this.state;\n\n        if (\n            // if a resize operation has just completed\n            repartitioning === false &&\n            prevState.repartitioning === true\n        ) {\n            // only invoke the callback if the UI has actually changed\n            if (overflow.length !== lastOverflowCount) {\n                this.props.onOverflow?.(overflow.slice());\n            }\n        } else if (!shallowCompareKeys(prevState, this.state)) {\n            this.repartition();\n        }\n    }\n\n    public render() {\n        const { className, collapseFrom, observeParents, style, tagName = \"div\", visibleItemRenderer } = this.props;\n        const overflow = this.maybeRenderOverflow();\n        const list = React.createElement(\n            tagName,\n            {\n                className: classNames(Classes.OVERFLOW_LIST, className),\n                style,\n            },\n            collapseFrom === Boundary.START ? overflow : null,\n            this.state.visible.map(visibleItemRenderer),\n            collapseFrom === Boundary.END ? overflow : null,\n            <div className={Classes.OVERFLOW_LIST_SPACER} ref={ref => (this.spacer = ref)} />,\n        );\n\n        return (\n            <ResizeSensor onResize={this.resize} observeParents={observeParents}>\n                {list}\n            </ResizeSensor>\n        );\n    }\n\n    private maybeRenderOverflow() {\n        const { overflow } = this.state;\n        if (overflow.length === 0 && !this.props.alwaysRenderOverflow) {\n            return null;\n        }\n        return this.props.overflowRenderer(overflow.slice());\n    }\n\n    private resize = () => {\n        this.repartition();\n    };\n\n    private repartition() {\n        if (this.spacer == null) {\n            return;\n        }\n\n        // if lastChopSize was 1, then our binary search has exhausted.\n        const partitionExhausted = this.state.lastChopSize === 1;\n        const minVisible = this.props.minVisibleItems ?? 0;\n\n        // spacer has flex-shrink and width 1px so if it's much smaller then we know to shrink\n        const shouldShrink = this.spacer.offsetWidth < 0.9 && this.state.visible.length > minVisible;\n\n        // we only check partitionExhausted for shouldGrow to ensure shrinking is the final operation.\n        const shouldGrow =\n            (this.spacer.offsetWidth >= 1 || this.state.visible.length < minVisible) &&\n            this.state.overflow.length > 0 &&\n            !partitionExhausted;\n\n        if (shouldShrink || shouldGrow) {\n            this.setState(state => {\n                let visible;\n                let overflow;\n                if (this.props.collapseFrom === Boundary.END) {\n                    const result = shiftElements(\n                        state.visible,\n                        state.overflow,\n                        this.state.chopSize * (shouldShrink ? 1 : -1),\n                    );\n                    visible = result[0];\n                    overflow = result[1];\n                } else {\n                    const result = shiftElements(\n                        state.overflow,\n                        state.visible,\n                        this.state.chopSize * (shouldShrink ? -1 : 1),\n                    );\n                    overflow = result[0];\n                    visible = result[1];\n                }\n\n                return {\n                    chopSize: halve(state.chopSize),\n                    lastChopSize: state.chopSize,\n                    // if we're starting a new partition cycle, record the last overflow count so we can track whether the UI changes after the new overflow is calculated\n                    lastOverflowCount: this.isFirstPartitionCycle(state.chopSize)\n                        ? state.overflow.length\n                        : state.lastOverflowCount,\n                    overflow,\n                    repartitioning: true,\n                    visible,\n                };\n            });\n        } else {\n            // repartition complete!\n            this.setState({\n                chopSize: this.defaultChopSize(),\n                lastChopSize: null,\n                repartitioning: false,\n            });\n        }\n    }\n\n    private defaultChopSize(): number {\n        return halve(this.props.items.length);\n    }\n\n    private isFirstPartitionCycle(currentChopSize: number): boolean {\n        return currentChopSize === this.defaultChopSize();\n    }\n}\n\nfunction halve(num: number): number {\n    return Math.ceil(num / 2);\n}\n\nfunction shiftElements<T>(leftArray: readonly T[], rightArray: readonly T[], num: number): [newFrom: T[], newTo: T[]] {\n    // if num is positive then elements are shifted from left-to-right, if negative then right-to-left\n    const allElements = leftArray.concat(rightArray);\n    const newLeftLength = leftArray.length - num;\n\n    if (newLeftLength <= 0) {\n        return [[], allElements];\n    } else if (newLeftLength >= allElements.length) {\n        return [allElements, []];\n    }\n\n    const sliceIndex = allElements.length - newLeftLength;\n\n    return [allElements.slice(0, -sliceIndex), allElements.slice(-sliceIndex)];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}