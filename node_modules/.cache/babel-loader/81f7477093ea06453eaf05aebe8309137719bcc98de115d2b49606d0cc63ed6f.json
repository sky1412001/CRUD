{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { AbstractPureComponent, Classes, Utils } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { clamp } from \"../../common/utils\";\nimport { formatPercentage } from \"./sliderUtils\";\n// props that require number values, for validation\nvar NUMBER_PROPS = [\"max\", \"min\", \"stepSize\", \"tickSize\", \"value\"];\n/** Internal component for a Handle with click/drag/keyboard logic to determine a new value. */\nvar Handle = /** @class */function (_super) {\n  __extends(Handle, _super);\n  function Handle() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.state = {\n      isMoving: false\n    };\n    _this.handleElement = null;\n    _this.refHandlers = {\n      handle: function (el) {\n        return _this.handleElement = el;\n      }\n    };\n    _this.beginHandleMovement = function (event) {\n      document.addEventListener(\"mousemove\", _this.handleHandleMovement);\n      document.addEventListener(\"mouseup\", _this.endHandleMovement);\n      _this.setState({\n        isMoving: true\n      });\n      _this.changeValue(_this.clientToValue(_this.mouseEventClientOffset(event)));\n    };\n    _this.beginHandleTouchMovement = function (event) {\n      document.addEventListener(\"touchmove\", _this.handleHandleTouchMovement);\n      document.addEventListener(\"touchend\", _this.endHandleTouchMovement);\n      document.addEventListener(\"touchcancel\", _this.endHandleTouchMovement);\n      _this.setState({\n        isMoving: true\n      });\n      _this.changeValue(_this.clientToValue(_this.touchEventClientOffset(event)));\n    };\n    _this.getStyleProperties = function () {\n      if (_this.handleElement == null) {\n        return {};\n      }\n      // The handle midpoint of RangeSlider is actually shifted by a margin to\n      // be on the edge of the visible handle element. Because the midpoint\n      // calculation does not take this margin into account, we instead\n      // measure the long side (which is equal to the short side plus the\n      // margin).\n      var _a = _this.props,\n        _b = _a.min,\n        min = _b === void 0 ? 0 : _b,\n        tickSizeRatio = _a.tickSizeRatio,\n        value = _a.value,\n        vertical = _a.vertical;\n      var handleMidpoint = _this.getHandleMidpointAndOffset(_this.handleElement, true).handleMidpoint;\n      var offsetRatio = (value - min) * tickSizeRatio;\n      var offsetCalc = \"calc(\".concat(formatPercentage(offsetRatio), \" - \").concat(handleMidpoint, \"px)\");\n      return vertical ? {\n        bottom: offsetCalc\n      } : {\n        left: offsetCalc\n      };\n    };\n    _this.endHandleMovement = function (event) {\n      _this.handleMoveEndedAt(_this.mouseEventClientOffset(event));\n    };\n    _this.endHandleTouchMovement = function (event) {\n      _this.handleMoveEndedAt(_this.touchEventClientOffset(event));\n    };\n    _this.handleMoveEndedAt = function (clientPixel) {\n      var _a, _b;\n      _this.removeDocumentEventListeners();\n      _this.setState({\n        isMoving: false\n      });\n      // always invoke onRelease; changeValue may call onChange if value is different\n      var finalValue = _this.changeValue(_this.clientToValue(clientPixel));\n      (_b = (_a = _this.props).onRelease) === null || _b === void 0 ? void 0 : _b.call(_a, finalValue);\n    };\n    _this.handleHandleMovement = function (event) {\n      _this.handleMovedTo(_this.mouseEventClientOffset(event));\n    };\n    _this.handleHandleTouchMovement = function (event) {\n      _this.handleMovedTo(_this.touchEventClientOffset(event));\n    };\n    _this.handleMovedTo = function (clientPixel) {\n      if (_this.state.isMoving && !_this.props.disabled) {\n        _this.changeValue(_this.clientToValue(clientPixel));\n      }\n    };\n    _this.handleKeyDown = function (event) {\n      var _a = _this.props,\n        stepSize = _a.stepSize,\n        value = _a.value;\n      var key = event.key;\n      if (key === \"ArrowDown\" || key === \"ArrowLeft\") {\n        _this.changeValue(value - stepSize);\n        // this key event has been handled! prevent browser scroll on up/down\n        event.preventDefault();\n      } else if (key === \"ArrowUp\" || key === \"ArrowRight\") {\n        _this.changeValue(value + stepSize);\n        event.preventDefault();\n      }\n    };\n    _this.handleKeyUp = function (event) {\n      var _a, _b;\n      if (Utils.isArrowKey(event)) {\n        (_b = (_a = _this.props).onRelease) === null || _b === void 0 ? void 0 : _b.call(_a, _this.props.value);\n      }\n    };\n    return _this;\n  }\n  Handle.prototype.componentDidMount = function () {\n    // The first time this component renders, it has no ref to the handle and thus incorrectly centers the handle.\n    // Therefore, on the first mount, force a re-render to center the handle with the ref'd component.\n    this.forceUpdate();\n  };\n  Handle.prototype.render = function () {\n    var _a;\n    var _b = this.props,\n      className = _b.className,\n      disabled = _b.disabled,\n      label = _b.label,\n      min = _b.min,\n      max = _b.max,\n      value = _b.value,\n      vertical = _b.vertical,\n      htmlProps = _b.htmlProps;\n    var isMoving = this.state.isMoving;\n    return React.createElement(\"span\", __assign({\n      role: \"slider\",\n      tabIndex: 0\n    }, htmlProps, {\n      className: classNames(Classes.SLIDER_HANDLE, (_a = {}, _a[Classes.ACTIVE] = isMoving, _a), className),\n      onKeyDown: disabled ? undefined : this.handleKeyDown,\n      onKeyUp: disabled ? undefined : this.handleKeyUp,\n      onMouseDown: disabled ? undefined : this.beginHandleMovement,\n      onTouchStart: disabled ? undefined : this.beginHandleTouchMovement,\n      ref: this.refHandlers.handle,\n      style: this.getStyleProperties(),\n      \"aria-valuemin\": min,\n      \"aria-valuemax\": max,\n      \"aria-valuenow\": value,\n      \"aria-orientation\": vertical ? \"vertical\" : \"horizontal\"\n    }), label == null ? null : React.createElement(\"span\", {\n      className: Classes.SLIDER_LABEL\n    }, label));\n  };\n  Handle.prototype.componentWillUnmount = function () {\n    this.removeDocumentEventListeners();\n  };\n  /** Convert client pixel to value between min and max. */\n  Handle.prototype.clientToValue = function (clientPixel) {\n    var _a = this.props,\n      stepSize = _a.stepSize,\n      tickSize = _a.tickSize,\n      value = _a.value,\n      vertical = _a.vertical;\n    if (this.handleElement == null) {\n      return value;\n    }\n    // #1769: this logic doesn't work perfectly when the tick size is\n    // smaller than the handle size; it may be off by a tick or two.\n    var clientPixelNormalized = vertical ? window.innerHeight - clientPixel : clientPixel;\n    var handleCenterPixel = this.getHandleElementCenterPixel(this.handleElement);\n    var pixelDelta = clientPixelNormalized - handleCenterPixel;\n    if (isNaN(pixelDelta)) {\n      return value;\n    }\n    // convert pixels to range value in increments of `stepSize`\n    return value + Math.round(pixelDelta / (tickSize * stepSize)) * stepSize;\n  };\n  Handle.prototype.mouseEventClientOffset = function (event) {\n    return this.props.vertical ? event.clientY : event.clientX;\n  };\n  Handle.prototype.touchEventClientOffset = function (event) {\n    var touch = event.changedTouches[0];\n    return this.props.vertical ? touch.clientY : touch.clientX;\n  };\n  Handle.prototype.validateProps = function (props) {\n    for (var _i = 0, NUMBER_PROPS_1 = NUMBER_PROPS; _i < NUMBER_PROPS_1.length; _i++) {\n      var prop = NUMBER_PROPS_1[_i];\n      if (typeof props[prop] !== \"number\") {\n        throw new Error(\"[Blueprint] <Handle> requires number value for \".concat(prop, \" prop\"));\n      }\n    }\n  };\n  /** Clamp value and invoke callback if it differs from current value */\n  Handle.prototype.changeValue = function (newValue, callback) {\n    if (callback === void 0) {\n      callback = this.props.onChange;\n    }\n    newValue = this.clamp(newValue);\n    if (!isNaN(newValue) && this.props.value !== newValue) {\n      callback === null || callback === void 0 ? void 0 : callback(newValue);\n    }\n    return newValue;\n  };\n  /** Clamp value between min and max props */\n  Handle.prototype.clamp = function (value) {\n    return clamp(value, this.props.min, this.props.max);\n  };\n  Handle.prototype.getHandleElementCenterPixel = function (handleElement) {\n    var _a = this.getHandleMidpointAndOffset(handleElement),\n      handleMidpoint = _a.handleMidpoint,\n      handleOffset = _a.handleOffset;\n    return handleOffset + handleMidpoint;\n  };\n  Handle.prototype.getHandleMidpointAndOffset = function (handleElement, useOppositeDimension) {\n    if (useOppositeDimension === void 0) {\n      useOppositeDimension = false;\n    }\n    if (handleElement == null) {\n      return {\n        handleMidpoint: 0,\n        handleOffset: 0\n      };\n    }\n    var vertical = this.props.vertical;\n    // getBoundingClientRect().height includes border size; clientHeight does not.\n    var handleRect = handleElement.getBoundingClientRect();\n    var sizeKey = vertical ? useOppositeDimension ? \"width\" : \"height\" : useOppositeDimension ? \"height\" : \"width\";\n    // \"bottom\" value seems to be consistently incorrect, so explicitly\n    // calculate it using the window offset instead.\n    var handleOffset = vertical ? window.innerHeight - (handleRect.top + handleRect[sizeKey]) : handleRect.left;\n    return {\n      handleMidpoint: handleRect[sizeKey] / 2,\n      handleOffset: handleOffset\n    };\n  };\n  Handle.prototype.removeDocumentEventListeners = function () {\n    document.removeEventListener(\"mousemove\", this.handleHandleMovement);\n    document.removeEventListener(\"mouseup\", this.endHandleMovement);\n    document.removeEventListener(\"touchmove\", this.handleHandleTouchMovement);\n    document.removeEventListener(\"touchend\", this.endHandleTouchMovement);\n    document.removeEventListener(\"touchcancel\", this.endHandleTouchMovement);\n  };\n  Handle.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".SliderHandle\");\n  return Handle;\n}(AbstractPureComponent);\nexport { Handle };","map":{"version":3,"names":["classNames","React","AbstractPureComponent","Classes","Utils","DISPLAYNAME_PREFIX","clamp","formatPercentage","NUMBER_PROPS","Handle","_super","__extends","_this","apply","arguments","state","isMoving","handleElement","refHandlers","handle","el","beginHandleMovement","event","document","addEventListener","handleHandleMovement","endHandleMovement","setState","changeValue","clientToValue","mouseEventClientOffset","beginHandleTouchMovement","handleHandleTouchMovement","endHandleTouchMovement","touchEventClientOffset","getStyleProperties","_a","props","_b","min","tickSizeRatio","value","vertical","handleMidpoint","getHandleMidpointAndOffset","offsetRatio","offsetCalc","concat","bottom","left","handleMoveEndedAt","clientPixel","removeDocumentEventListeners","finalValue","onRelease","call","handleMovedTo","disabled","handleKeyDown","stepSize","key","preventDefault","handleKeyUp","isArrowKey","prototype","componentDidMount","forceUpdate","render","className","label","max","htmlProps","createElement","__assign","role","tabIndex","SLIDER_HANDLE","ACTIVE","onKeyDown","undefined","onKeyUp","onMouseDown","onTouchStart","ref","style","SLIDER_LABEL","componentWillUnmount","tickSize","clientPixelNormalized","window","innerHeight","handleCenterPixel","getHandleElementCenterPixel","pixelDelta","isNaN","Math","round","clientY","clientX","touch","changedTouches","validateProps","_i","NUMBER_PROPS_1","length","prop","Error","newValue","callback","onChange","handleOffset","useOppositeDimension","handleRect","getBoundingClientRect","sizeKey","top","removeEventListener","displayName"],"sources":["/home/meander/Desktop/Akash/Workit/my-app/node_modules/@blueprintjs/core/src/components/slider/handle.tsx"],"sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport { AbstractPureComponent, Classes, Utils } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { clamp } from \"../../common/utils\";\nimport { HandleProps } from \"./handleProps\";\nimport { formatPercentage } from \"./sliderUtils\";\n\n/**\n * Props for the internal <Handle> component needs some additional info from the parent Slider.\n */\nexport interface InternalHandleProps extends HandleProps {\n    disabled?: boolean;\n    label: JSX.Element | string | undefined;\n    max: number;\n    min: number;\n    stepSize: number;\n    tickSize: number;\n    tickSizeRatio: number;\n    vertical: boolean;\n}\n\nexport interface HandleState {\n    /** whether slider handle is currently being dragged */\n    isMoving?: boolean;\n}\n\n// props that require number values, for validation\nconst NUMBER_PROPS = [\"max\", \"min\", \"stepSize\", \"tickSize\", \"value\"];\n\n/** Internal component for a Handle with click/drag/keyboard logic to determine a new value. */\nexport class Handle extends AbstractPureComponent<InternalHandleProps, HandleState> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.SliderHandle`;\n\n    public state = {\n        isMoving: false,\n    };\n\n    private handleElement: HTMLElement | null = null;\n\n    private refHandlers = {\n        handle: (el: HTMLSpanElement) => (this.handleElement = el),\n    };\n\n    public componentDidMount() {\n        // The first time this component renders, it has no ref to the handle and thus incorrectly centers the handle.\n        // Therefore, on the first mount, force a re-render to center the handle with the ref'd component.\n        this.forceUpdate();\n    }\n\n    public render() {\n        const { className, disabled, label, min, max, value, vertical, htmlProps } = this.props;\n        const { isMoving } = this.state;\n\n        return (\n            <span\n                role=\"slider\"\n                tabIndex={0}\n                {...htmlProps}\n                className={classNames(Classes.SLIDER_HANDLE, { [Classes.ACTIVE]: isMoving }, className)}\n                onKeyDown={disabled ? undefined : this.handleKeyDown}\n                onKeyUp={disabled ? undefined : this.handleKeyUp}\n                onMouseDown={disabled ? undefined : this.beginHandleMovement}\n                onTouchStart={disabled ? undefined : this.beginHandleTouchMovement}\n                ref={this.refHandlers.handle}\n                style={this.getStyleProperties()}\n                aria-valuemin={min}\n                aria-valuemax={max}\n                aria-valuenow={value}\n                aria-orientation={vertical ? \"vertical\" : \"horizontal\"}\n            >\n                {label == null ? null : <span className={Classes.SLIDER_LABEL}>{label}</span>}\n            </span>\n        );\n    }\n\n    public componentWillUnmount() {\n        this.removeDocumentEventListeners();\n    }\n\n    /** Convert client pixel to value between min and max. */\n    public clientToValue(clientPixel: number) {\n        const { stepSize, tickSize, value, vertical } = this.props;\n        if (this.handleElement == null) {\n            return value;\n        }\n\n        // #1769: this logic doesn't work perfectly when the tick size is\n        // smaller than the handle size; it may be off by a tick or two.\n        const clientPixelNormalized = vertical ? window.innerHeight - clientPixel : clientPixel;\n        const handleCenterPixel = this.getHandleElementCenterPixel(this.handleElement);\n        const pixelDelta = clientPixelNormalized - handleCenterPixel;\n\n        if (isNaN(pixelDelta)) {\n            return value;\n        }\n        // convert pixels to range value in increments of `stepSize`\n        return value + Math.round(pixelDelta / (tickSize * stepSize)) * stepSize;\n    }\n\n    public mouseEventClientOffset(event: MouseEvent | React.MouseEvent<HTMLElement>) {\n        return this.props.vertical ? event.clientY : event.clientX;\n    }\n\n    public touchEventClientOffset(event: TouchEvent | React.TouchEvent<HTMLElement>) {\n        const touch = event.changedTouches[0];\n        return this.props.vertical ? touch.clientY : touch.clientX;\n    }\n\n    public beginHandleMovement = (event: MouseEvent | React.MouseEvent<HTMLElement>) => {\n        document.addEventListener(\"mousemove\", this.handleHandleMovement);\n        document.addEventListener(\"mouseup\", this.endHandleMovement);\n        this.setState({ isMoving: true });\n        this.changeValue(this.clientToValue(this.mouseEventClientOffset(event)));\n    };\n\n    public beginHandleTouchMovement = (event: TouchEvent | React.TouchEvent<HTMLElement>) => {\n        document.addEventListener(\"touchmove\", this.handleHandleTouchMovement);\n        document.addEventListener(\"touchend\", this.endHandleTouchMovement);\n        document.addEventListener(\"touchcancel\", this.endHandleTouchMovement);\n        this.setState({ isMoving: true });\n        this.changeValue(this.clientToValue(this.touchEventClientOffset(event)));\n    };\n\n    protected validateProps(props: InternalHandleProps) {\n        for (const prop of NUMBER_PROPS) {\n            if (typeof (props as any)[prop] !== \"number\") {\n                throw new Error(`[Blueprint] <Handle> requires number value for ${prop} prop`);\n            }\n        }\n    }\n\n    private getStyleProperties = (): React.CSSProperties => {\n        if (this.handleElement == null) {\n            return {};\n        }\n\n        // The handle midpoint of RangeSlider is actually shifted by a margin to\n        // be on the edge of the visible handle element. Because the midpoint\n        // calculation does not take this margin into account, we instead\n        // measure the long side (which is equal to the short side plus the\n        // margin).\n\n        const { min = 0, tickSizeRatio, value, vertical } = this.props;\n        const { handleMidpoint } = this.getHandleMidpointAndOffset(this.handleElement, true);\n        const offsetRatio = (value - min) * tickSizeRatio;\n        const offsetCalc = `calc(${formatPercentage(offsetRatio)} - ${handleMidpoint}px)`;\n        return vertical ? { bottom: offsetCalc } : { left: offsetCalc };\n    };\n\n    private endHandleMovement = (event: MouseEvent) => {\n        this.handleMoveEndedAt(this.mouseEventClientOffset(event));\n    };\n\n    private endHandleTouchMovement = (event: TouchEvent) => {\n        this.handleMoveEndedAt(this.touchEventClientOffset(event));\n    };\n\n    private handleMoveEndedAt = (clientPixel: number) => {\n        this.removeDocumentEventListeners();\n        this.setState({ isMoving: false });\n        // always invoke onRelease; changeValue may call onChange if value is different\n        const finalValue = this.changeValue(this.clientToValue(clientPixel));\n        this.props.onRelease?.(finalValue);\n    };\n\n    private handleHandleMovement = (event: MouseEvent) => {\n        this.handleMovedTo(this.mouseEventClientOffset(event));\n    };\n\n    private handleHandleTouchMovement = (event: TouchEvent) => {\n        this.handleMovedTo(this.touchEventClientOffset(event));\n    };\n\n    private handleMovedTo = (clientPixel: number) => {\n        if (this.state.isMoving && !this.props.disabled) {\n            this.changeValue(this.clientToValue(clientPixel));\n        }\n    };\n\n    private handleKeyDown = (event: React.KeyboardEvent<HTMLSpanElement>) => {\n        const { stepSize, value } = this.props;\n        const { key } = event;\n        if (key === \"ArrowDown\" || key === \"ArrowLeft\") {\n            this.changeValue(value - stepSize);\n            // this key event has been handled! prevent browser scroll on up/down\n            event.preventDefault();\n        } else if (key === \"ArrowUp\" || key === \"ArrowRight\") {\n            this.changeValue(value + stepSize);\n            event.preventDefault();\n        }\n    };\n\n    private handleKeyUp = (event: React.KeyboardEvent<HTMLSpanElement>) => {\n        if (Utils.isArrowKey(event)) {\n            this.props.onRelease?.(this.props.value);\n        }\n    };\n\n    /** Clamp value and invoke callback if it differs from current value */\n    private changeValue(newValue: number, callback = this.props.onChange) {\n        newValue = this.clamp(newValue);\n        if (!isNaN(newValue) && this.props.value !== newValue) {\n            callback?.(newValue);\n        }\n        return newValue;\n    }\n\n    /** Clamp value between min and max props */\n    private clamp(value: number) {\n        return clamp(value, this.props.min, this.props.max);\n    }\n\n    private getHandleElementCenterPixel(handleElement: HTMLElement) {\n        const { handleMidpoint, handleOffset } = this.getHandleMidpointAndOffset(handleElement);\n        return handleOffset + handleMidpoint;\n    }\n\n    private getHandleMidpointAndOffset(handleElement: HTMLElement, useOppositeDimension = false) {\n        if (handleElement == null) {\n            return { handleMidpoint: 0, handleOffset: 0 };\n        }\n\n        const { vertical } = this.props;\n\n        // getBoundingClientRect().height includes border size; clientHeight does not.\n        const handleRect = handleElement.getBoundingClientRect();\n\n        const sizeKey = vertical\n            ? useOppositeDimension\n                ? \"width\"\n                : \"height\"\n            : useOppositeDimension\n            ? \"height\"\n            : \"width\";\n\n        // \"bottom\" value seems to be consistently incorrect, so explicitly\n        // calculate it using the window offset instead.\n        const handleOffset = vertical ? window.innerHeight - (handleRect.top + handleRect[sizeKey]) : handleRect.left;\n\n        return { handleMidpoint: handleRect[sizeKey] / 2, handleOffset };\n    }\n\n    private removeDocumentEventListeners() {\n        document.removeEventListener(\"mousemove\", this.handleHandleMovement);\n        document.removeEventListener(\"mouseup\", this.endHandleMovement);\n        document.removeEventListener(\"touchmove\", this.handleHandleTouchMovement);\n        document.removeEventListener(\"touchend\", this.endHandleTouchMovement);\n        document.removeEventListener(\"touchcancel\", this.endHandleTouchMovement);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}