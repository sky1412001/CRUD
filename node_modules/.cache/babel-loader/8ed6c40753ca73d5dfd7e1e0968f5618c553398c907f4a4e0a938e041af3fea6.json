{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview This component is DEPRECATED, and the code is frozen.\n * All changes & bugfixes should be made to HotkeysDialog2 instead.\n */\n/* eslint-disable deprecation/deprecation */\nimport { Children } from \"react\";\nimport { isElementOfType } from \"../common/utils\";\nimport { Hotkey } from \"../components/hotkeys\";\nimport { comboMatches, getKeyCombo, parseKeyCombo } from \"../components/hotkeys/hotkeyParser\";\nimport { hideHotkeysDialogAfterDelay, isHotkeysDialogShowing, showHotkeysDialog } from \"./hotkeysDialogLegacy\";\nvar SHOW_DIALOG_KEY = \"?\";\nexport var HotkeyScope;\n(function (HotkeyScope) {\n  HotkeyScope[\"LOCAL\"] = \"local\";\n  HotkeyScope[\"GLOBAL\"] = \"global\";\n})(HotkeyScope || (HotkeyScope = {}));\nvar HotkeysEvents = /** @class */function () {\n  function HotkeysEvents(scope) {\n    var _this = this;\n    this.scope = scope;\n    this.actions = [];\n    this.handleKeyDown = function (e) {\n      var combo = getKeyCombo(e);\n      var isTextInput = _this.isTextInput(e);\n      if (!isTextInput && comboMatches(parseKeyCombo(SHOW_DIALOG_KEY), combo)) {\n        if (isHotkeysDialogShowing()) {\n          hideHotkeysDialogAfterDelay();\n        } else {\n          showHotkeysDialog(_this.actions.map(function (action) {\n            return action.props;\n          }));\n        }\n        return;\n      } else if (isHotkeysDialogShowing()) {\n        return;\n      }\n      _this.invokeNamedCallbackIfComboRecognized(combo, \"onKeyDown\", e);\n    };\n    this.handleKeyUp = function (e) {\n      if (isHotkeysDialogShowing()) {\n        return;\n      }\n      _this.invokeNamedCallbackIfComboRecognized(getKeyCombo(e), \"onKeyUp\", e);\n    };\n  }\n  HotkeysEvents.prototype.count = function () {\n    return this.actions.length;\n  };\n  HotkeysEvents.prototype.clear = function () {\n    this.actions = [];\n  };\n  HotkeysEvents.prototype.setHotkeys = function (props) {\n    var _this = this;\n    var actions = [];\n    Children.forEach(props.children, function (child) {\n      if (isElementOfType(child, Hotkey) && _this.isScope(child.props)) {\n        actions.push({\n          combo: parseKeyCombo(child.props.combo),\n          props: child.props\n        });\n      }\n    });\n    this.actions = actions;\n  };\n  HotkeysEvents.prototype.invokeNamedCallbackIfComboRecognized = function (combo, callbackName, e) {\n    var _a, _b;\n    var isTextInput = this.isTextInput(e);\n    for (var _i = 0, _c = this.actions; _i < _c.length; _i++) {\n      var action = _c[_i];\n      var shouldIgnore = isTextInput && !action.props.allowInInput || action.props.disabled;\n      if (!shouldIgnore && comboMatches(action.combo, combo)) {\n        if (action.props.preventDefault) {\n          e.preventDefault();\n        }\n        if (action.props.stopPropagation) {\n          // set a flag just for unit testing. not meant to be referenced in feature work.\n          e.isPropagationStopped = true;\n          e.stopPropagation();\n        }\n        (_b = (_a = action.props)[callbackName]) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n      }\n    }\n  };\n  HotkeysEvents.prototype.isScope = function (props) {\n    return (props.global ? HotkeyScope.GLOBAL : HotkeyScope.LOCAL) === this.scope;\n  };\n  HotkeysEvents.prototype.isTextInput = function (e) {\n    var elem = e.target;\n    // we check these cases for unit testing, but this should not happen\n    // during normal operation\n    if (elem == null || elem.closest == null) {\n      return false;\n    }\n    var editable = elem.closest(\"input, textarea, [contenteditable=true]\");\n    if (editable == null) {\n      return false;\n    }\n    // don't let checkboxes, switches, and radio buttons prevent hotkey behavior\n    if (editable.tagName.toLowerCase() === \"input\") {\n      var inputType = editable.type;\n      if (inputType === \"checkbox\" || inputType === \"radio\") {\n        return false;\n      }\n    }\n    // don't let read-only fields prevent hotkey behavior\n    if (editable.readOnly) {\n      return false;\n    }\n    return true;\n  };\n  return HotkeysEvents;\n}();\nexport { HotkeysEvents };","map":{"version":3,"names":["Children","isElementOfType","Hotkey","comboMatches","getKeyCombo","parseKeyCombo","hideHotkeysDialogAfterDelay","isHotkeysDialogShowing","showHotkeysDialog","SHOW_DIALOG_KEY","HotkeyScope","HotkeysEvents","scope","_this","actions","handleKeyDown","e","combo","isTextInput","map","action","props","invokeNamedCallbackIfComboRecognized","handleKeyUp","prototype","count","length","clear","setHotkeys","forEach","children","child","isScope","push","callbackName","_i","_c","shouldIgnore","allowInInput","disabled","preventDefault","stopPropagation","isPropagationStopped","_b","_a","call","global","GLOBAL","LOCAL","elem","target","closest","editable","tagName","toLowerCase","inputType","type","readOnly"],"sources":["/home/meander/Desktop/Akash/Workit/my-app/node_modules/@blueprintjs/core/src/legacy/hotkeysEvents.ts"],"sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview This component is DEPRECATED, and the code is frozen.\n * All changes & bugfixes should be made to HotkeysDialog2 instead.\n */\n\n/* eslint-disable deprecation/deprecation */\n\nimport { Children, ReactNode } from \"react\";\n\nimport { isElementOfType } from \"../common/utils\";\nimport { Hotkey, HotkeyProps, HotkeysProps } from \"../components/hotkeys\";\nimport { comboMatches, getKeyCombo, KeyCombo, parseKeyCombo } from \"../components/hotkeys/hotkeyParser\";\nimport { hideHotkeysDialogAfterDelay, isHotkeysDialogShowing, showHotkeysDialog } from \"./hotkeysDialogLegacy\";\n\nconst SHOW_DIALOG_KEY = \"?\";\n\nexport enum HotkeyScope {\n    LOCAL = \"local\",\n    GLOBAL = \"global\",\n}\n\nexport interface IHotkeyAction {\n    combo: KeyCombo;\n    props: HotkeyProps;\n}\n\nexport class HotkeysEvents {\n    private actions = [] as IHotkeyAction[];\n\n    public constructor(private scope: HotkeyScope) {}\n\n    public count() {\n        return this.actions.length;\n    }\n\n    public clear() {\n        this.actions = [];\n    }\n\n    public setHotkeys(props: HotkeysProps & { children?: ReactNode }) {\n        const actions = [] as IHotkeyAction[];\n        Children.forEach(props.children, (child: ReactNode) => {\n            if (isElementOfType(child, Hotkey) && this.isScope(child.props)) {\n                actions.push({\n                    combo: parseKeyCombo(child.props.combo),\n                    props: child.props,\n                });\n            }\n        });\n        this.actions = actions;\n    }\n\n    public handleKeyDown = (e: KeyboardEvent) => {\n        const combo = getKeyCombo(e);\n        const isTextInput = this.isTextInput(e);\n\n        if (!isTextInput && comboMatches(parseKeyCombo(SHOW_DIALOG_KEY), combo)) {\n            if (isHotkeysDialogShowing()) {\n                hideHotkeysDialogAfterDelay();\n            } else {\n                showHotkeysDialog(this.actions.map(action => action.props));\n            }\n            return;\n        } else if (isHotkeysDialogShowing()) {\n            return;\n        }\n\n        this.invokeNamedCallbackIfComboRecognized(combo, \"onKeyDown\", e);\n    };\n\n    public handleKeyUp = (e: KeyboardEvent) => {\n        if (isHotkeysDialogShowing()) {\n            return;\n        }\n        this.invokeNamedCallbackIfComboRecognized(getKeyCombo(e), \"onKeyUp\", e);\n    };\n\n    private invokeNamedCallbackIfComboRecognized(\n        combo: KeyCombo,\n        callbackName: \"onKeyDown\" | \"onKeyUp\",\n        e: KeyboardEvent,\n    ) {\n        const isTextInput = this.isTextInput(e);\n        for (const action of this.actions) {\n            const shouldIgnore = (isTextInput && !action.props.allowInInput) || action.props.disabled;\n            if (!shouldIgnore && comboMatches(action.combo, combo)) {\n                if (action.props.preventDefault) {\n                    e.preventDefault();\n                }\n                if (action.props.stopPropagation) {\n                    // set a flag just for unit testing. not meant to be referenced in feature work.\n                    (e as any).isPropagationStopped = true;\n                    e.stopPropagation();\n                }\n                action.props[callbackName]?.(e);\n            }\n        }\n    }\n\n    private isScope(props: HotkeyProps) {\n        return (props.global ? HotkeyScope.GLOBAL : HotkeyScope.LOCAL) === this.scope;\n    }\n\n    private isTextInput(e: KeyboardEvent) {\n        const elem = e.target as HTMLElement;\n        // we check these cases for unit testing, but this should not happen\n        // during normal operation\n        if (elem == null || elem.closest == null) {\n            return false;\n        }\n\n        const editable = elem.closest(\"input, textarea, [contenteditable=true]\");\n\n        if (editable == null) {\n            return false;\n        }\n\n        // don't let checkboxes, switches, and radio buttons prevent hotkey behavior\n        if (editable.tagName.toLowerCase() === \"input\") {\n            const inputType = (editable as HTMLInputElement).type;\n            if (inputType === \"checkbox\" || inputType === \"radio\") {\n                return false;\n            }\n        }\n\n        // don't let read-only fields prevent hotkey behavior\n        if ((editable as HTMLInputElement).readOnly) {\n            return false;\n        }\n\n        return true;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}