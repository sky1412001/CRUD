{"ast":null,"code":"/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { Manager, Popper, Reference } from \"react-popper\";\nimport { AbstractPureComponent, Classes, DISPLAYNAME_PREFIX, refHandler, Utils } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { Overlay } from \"../overlay/overlay\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\";\n// eslint-disable-next-line import/no-cycle\nimport { Tooltip } from \"../tooltip/tooltip\";\nimport { matchReferenceWidthModifier } from \"./customModifiers\";\nimport { POPOVER_ARROW_SVG_SIZE, PopoverArrow } from \"./popoverArrow\";\nimport { positionToPlacement } from \"./popoverPlacementUtils\";\nimport { getBasePlacement, getTransformOrigin } from \"./popperUtils\";\nexport var PopoverInteractionKind = {\n  CLICK: \"click\",\n  CLICK_TARGET_ONLY: \"click-target\",\n  HOVER: \"hover\",\n  HOVER_TARGET_ONLY: \"hover-target\"\n};\n/**\n * Popover component, used to display a floating UI next to and tethered to a target element.\n *\n * @template T target element props interface. Consumers wishing to stay in sync with Blueprint's default target HTML\n * props interface should use the `DefaultPopoverTargetHTMLProps` type (although this is already the default type for\n * this type param).\n * @see https://blueprintjs.com/docs/#core/components/popover\n */\nvar Popover = /** @class */function (_super) {\n  __extends(Popover, _super);\n  function Popover() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.state = {\n      hasDarkParent: false,\n      isOpen: _this.getIsOpen(_this.props)\n    };\n    /**\n     * DOM element that contains the popover.\n     * When `usePortal={true}`, this element will be portaled outside the usual DOM flow,\n     * so this reference can be very useful for testing.\n     *\n     * @public for testing\n     */\n    _this.popoverElement = null;\n    /** Popover ref handler */\n    _this.popoverRef = refHandler(_this, \"popoverElement\", _this.props.popoverRef);\n    /**\n     * Target DOM element ref.\n     *\n     * @public for testing\n     */\n    _this.targetRef = React.createRef();\n    // a flag that lets us detect mouse movement between the target and popover,\n    // now that mouseleave is triggered when you cross the gap between the two.\n    _this.isMouseInTargetOrPopover = false;\n    // a flag that indicates whether the target previously lost focus to another\n    // element on the same page.\n    _this.lostFocusOnSamePage = true;\n    _this.isControlled = function () {\n      return _this.props.isOpen !== undefined;\n    };\n    // arrow is disabled if minimal, or if the arrow modifier was explicitly disabled\n    _this.isArrowEnabled = function () {\n      var _a, _b;\n      return !_this.props.minimal && ((_b = (_a = _this.props.modifiers) === null || _a === void 0 ? void 0 : _a.arrow) === null || _b === void 0 ? void 0 : _b.enabled) !== false;\n    };\n    _this.isHoverInteractionKind = function () {\n      return _this.props.interactionKind === PopoverInteractionKind.HOVER || _this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY;\n    };\n    /**\n     * Instance method to instruct the `Popover` to recompute its position.\n     *\n     * This method should only be used if you are updating the target in a way\n     * that does not cause it to re-render, such as changing its _position_\n     * without changing its _size_ (since `Popover` already repositions when it\n     * detects a resize).\n     */\n    _this.reposition = function () {\n      var _a;\n      return (_a = _this.popperScheduleUpdate) === null || _a === void 0 ? void 0 : _a.call(_this);\n    };\n    _this.renderTarget = function (_a) {\n      var _b, _c;\n      var _d, _e;\n      var ref = _a.ref;\n      var _f = _this.props,\n        children = _f.children,\n        className = _f.className,\n        fill = _f.fill,\n        openOnTargetFocus = _f.openOnTargetFocus,\n        renderTarget = _f.renderTarget;\n      var isOpen = _this.state.isOpen;\n      var isControlled = _this.isControlled();\n      var isHoverInteractionKind = _this.isHoverInteractionKind();\n      var targetTagName = _this.props.targetTagName;\n      if (fill) {\n        targetTagName = \"div\";\n      }\n      var targetEventHandlers = isHoverInteractionKind ? {\n        // HOVER handlers\n        onBlur: _this.handleTargetBlur,\n        onContextMenu: _this.handleTargetContextMenu,\n        onFocus: _this.handleTargetFocus,\n        onMouseEnter: _this.handleMouseEnter,\n        onMouseLeave: _this.handleMouseLeave\n      } : {\n        // CLICK needs only one handler\n        onClick: _this.handleTargetClick,\n        // For keyboard accessibility, trigger the same behavior as a click event upon pressing ENTER/SPACE\n        onKeyDown: _this.handleKeyDown\n      };\n      // Ensure target is focusable if relevant prop enabled\n      var targetTabIndex = openOnTargetFocus && isHoverInteractionKind ? 0 : undefined;\n      var ownTargetProps = __assign({\n        \"aria-haspopup\": (_d = _this.props.popupKind) !== null && _d !== void 0 ? _d : _this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY ? undefined : \"true\",\n        // N.B. this.props.className is passed along to renderTarget even though the user would have access to it.\n        // If, instead, renderTarget is undefined and the target is provided as a child, this.props.className is\n        // applied to the generated target wrapper element.\n        className: classNames(className, Classes.POPOVER_TARGET, (_b = {}, _b[Classes.POPOVER_OPEN] = isOpen,\n        // this class is mainly useful for button targets\n        _b[Classes.ACTIVE] = isOpen && !isControlled && !isHoverInteractionKind, _b)),\n        ref: ref\n      }, targetEventHandlers);\n      var targetModifierClasses = (_c = {},\n      // this class is mainly useful for Blueprint <Button> targets; we should only apply it for\n      // uncontrolled popovers when they are opened by a user interaction\n      _c[Classes.ACTIVE] = isOpen && !isControlled && !isHoverInteractionKind,\n      // similarly, this class is mainly useful for targets like <Button>, <InputGroup>, etc.\n      _c[Classes.FILL] = fill, _c);\n      var target;\n      if (renderTarget !== undefined) {\n        target = renderTarget(__assign(__assign({}, ownTargetProps), {\n          className: classNames(ownTargetProps.className, targetModifierClasses),\n          // if the consumer renders a tooltip target, it's their responsibility to disable that tooltip\n          // when *this* popover is open\n          isOpen: isOpen,\n          tabIndex: targetTabIndex\n        }));\n      } else {\n        var childTarget = Utils.ensureElement(React.Children.toArray(children)[0]);\n        if (childTarget === undefined) {\n          return null;\n        }\n        var clonedTarget = React.cloneElement(childTarget, {\n          className: classNames(childTarget.props.className, targetModifierClasses),\n          // force disable single Tooltip child when popover is open\n          disabled: isOpen && Utils.isElementOfType(childTarget, Tooltip) ? true : childTarget.props.disabled,\n          tabIndex: (_e = childTarget.props.tabIndex) !== null && _e !== void 0 ? _e : targetTabIndex\n        });\n        var wrappedTarget = React.createElement(targetTagName, __assign(__assign({}, ownTargetProps), _this.props.targetProps), clonedTarget);\n        target = wrappedTarget;\n      }\n      // N.B. we must attach the ref ('wrapped' with react-popper functionality) to the DOM element here and\n      // let ResizeSensor know about it\n      return React.createElement(ResizeSensor, {\n        targetRef: _this.targetRef,\n        onResize: _this.reposition\n      }, target);\n    };\n    _this.renderPopover = function (popperProps) {\n      var _a;\n      var _b;\n      var _c = _this.props,\n        interactionKind = _c.interactionKind,\n        shouldReturnFocusOnClose = _c.shouldReturnFocusOnClose,\n        usePortal = _c.usePortal;\n      var isOpen = _this.state.isOpen;\n      // compute an appropriate transform origin so the scale animation points towards target\n      var transformOrigin = getTransformOrigin(popperProps.placement, _this.isArrowEnabled() ? popperProps.arrowProps.style : undefined);\n      // need to update our reference to this function on every render as it will change.\n      _this.popperScheduleUpdate = popperProps.update;\n      var popoverHandlers = {\n        // always check popover clicks for dismiss class\n        onClick: _this.handlePopoverClick,\n        // treat ENTER/SPACE keys the same as a click for accessibility\n        onKeyDown: function (event) {\n          return Utils.isKeyboardClick(event) && _this.handlePopoverClick(event);\n        }\n      };\n      if (interactionKind === PopoverInteractionKind.HOVER || !usePortal && interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY) {\n        popoverHandlers.onMouseEnter = _this.handleMouseEnter;\n        popoverHandlers.onMouseLeave = _this.handleMouseLeave;\n      }\n      var basePlacement = getBasePlacement(popperProps.placement);\n      var popoverClasses = classNames(Classes.POPOVER, (_a = {}, _a[Classes.DARK] = _this.props.inheritDarkTheme && _this.state.hasDarkParent, _a[Classes.MINIMAL] = _this.props.minimal, _a[Classes.POPOVER_CAPTURING_DISMISS] = _this.props.captureDismiss, _a[Classes.POPOVER_MATCH_TARGET_WIDTH] = _this.props.matchTargetWidth, _a[Classes.POPOVER_REFERENCE_HIDDEN] = popperProps.isReferenceHidden === true, _a[Classes.POPOVER_POPPER_ESCAPED] = popperProps.hasPopperEscaped === true, _a), \"\".concat(Classes.POPOVER_CONTENT_PLACEMENT, \"-\").concat(basePlacement), _this.props.popoverClassName);\n      var defaultAutoFocus = _this.isHoverInteractionKind() ? false : undefined;\n      return React.createElement(Overlay, {\n        autoFocus: (_b = _this.props.autoFocus) !== null && _b !== void 0 ? _b : defaultAutoFocus,\n        backdropClassName: Classes.POPOVER_BACKDROP,\n        backdropProps: _this.props.backdropProps,\n        canEscapeKeyClose: _this.props.canEscapeKeyClose,\n        canOutsideClickClose: _this.props.interactionKind === PopoverInteractionKind.CLICK,\n        enforceFocus: _this.props.enforceFocus,\n        hasBackdrop: _this.props.hasBackdrop,\n        isOpen: isOpen,\n        onClose: _this.handleOverlayClose,\n        onClosed: _this.props.onClosed,\n        onClosing: _this.props.onClosing,\n        onOpened: _this.props.onOpened,\n        onOpening: _this.props.onOpening,\n        transitionDuration: _this.props.transitionDuration,\n        transitionName: Classes.POPOVER,\n        usePortal: _this.props.usePortal,\n        portalClassName: _this.props.portalClassName,\n        portalContainer: _this.props.portalContainer,\n        // if hover interaction, it doesn't make sense to take over focus control\n        shouldReturnFocusOnClose: _this.isHoverInteractionKind() ? false : shouldReturnFocusOnClose\n      }, React.createElement(\"div\", {\n        className: Classes.POPOVER_TRANSITION_CONTAINER,\n        ref: popperProps.ref,\n        style: popperProps.style\n      }, React.createElement(ResizeSensor, {\n        onResize: _this.reposition\n      }, React.createElement(\"div\", __assign({\n        className: popoverClasses,\n        style: {\n          transformOrigin: transformOrigin\n        },\n        ref: _this.popoverRef\n      }, popoverHandlers), _this.isArrowEnabled() && React.createElement(PopoverArrow, {\n        arrowProps: popperProps.arrowProps,\n        placement: popperProps.placement\n      }), React.createElement(\"div\", {\n        className: Classes.POPOVER_CONTENT\n      }, _this.props.content)))));\n    };\n    _this.handleTargetFocus = function (e) {\n      if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n        if (e.relatedTarget == null && !_this.lostFocusOnSamePage) {\n          // ignore this focus event -- the target was already focused but the page itself\n          // lost focus (e.g. due to switching tabs).\n          return;\n        }\n        _this.handleMouseEnter(e);\n      }\n    };\n    _this.handleTargetBlur = function (e) {\n      if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n        if (e.relatedTarget != null) {\n          // if the next element to receive focus is within the popover, we'll want to leave the\n          // popover open.\n          if (e.relatedTarget !== _this.popoverElement && !_this.isElementInPopover(e.relatedTarget)) {\n            _this.handleMouseLeave(e);\n          }\n        } else {\n          _this.handleMouseLeave(e);\n        }\n      }\n      _this.lostFocusOnSamePage = e.relatedTarget != null;\n    };\n    _this.handleTargetContextMenu = function (e) {\n      // we assume that when someone prevents the default interaction on this event (a browser native context menu),\n      // they are showing a custom context menu (as ContextMenu2 does); in this case, we should close this popover/tooltip\n      if (e.defaultPrevented) {\n        _this.setOpenState(false, e);\n      }\n    };\n    _this.handleMouseEnter = function (e) {\n      _this.isMouseInTargetOrPopover = true;\n      // if we're entering the popover, and the mode is set to be HOVER_TARGET_ONLY, we want to manually\n      // trigger the mouse leave event, as hovering over the popover shouldn't count.\n      if (!_this.props.usePortal && _this.isElementInPopover(e.target) && _this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY && !_this.props.openOnTargetFocus) {\n        _this.handleMouseLeave(e);\n      } else if (!_this.props.disabled) {\n        // only begin opening popover when it is enabled\n        _this.setOpenState(true, e, _this.props.hoverOpenDelay);\n      }\n    };\n    _this.handleMouseLeave = function (e) {\n      _this.isMouseInTargetOrPopover = false;\n      // wait until the event queue is flushed, because we want to leave the\n      // popover open if the mouse entered the popover immediately after\n      // leaving the target (or vice versa).\n      _this.setTimeout(function () {\n        if (_this.isMouseInTargetOrPopover) {\n          return;\n        }\n        // user-configurable closing delay is helpful when moving mouse from target to popover\n        _this.setOpenState(false, e, _this.props.hoverCloseDelay);\n      });\n    };\n    _this.handlePopoverClick = function (e) {\n      var _a, _b, _c, _d;\n      var eventTarget = e.target;\n      var eventPopover = eventTarget.closest(\".\".concat(Classes.POPOVER));\n      var eventPopoverV1 = eventTarget.closest(\".\".concat(Classes.POPOVER));\n      var isEventFromSelf = (eventPopover !== null && eventPopover !== void 0 ? eventPopover : eventPopoverV1) === _this.getPopoverElement();\n      var isEventPopoverCapturing = (_b = (_a = eventPopover === null || eventPopover === void 0 ? void 0 : eventPopover.classList.contains(Classes.POPOVER_CAPTURING_DISMISS)) !== null && _a !== void 0 ? _a : eventPopoverV1 === null || eventPopoverV1 === void 0 ? void 0 : eventPopoverV1.classList.contains(Classes.POPOVER_CAPTURING_DISMISS)) !== null && _b !== void 0 ? _b : false;\n      // an OVERRIDE inside a DISMISS does not dismiss, and a DISMISS inside an OVERRIDE will dismiss.\n      var dismissElement = eventTarget.closest(\".\".concat(Classes.POPOVER_DISMISS, \", .\").concat(Classes.POPOVER_DISMISS_OVERRIDE));\n      // dismiss selectors from the \"V1\" version of Popover in the core package\n      // we expect these to be rendered by MenuItem, which at this point has no knowledge of Popover\n      // this can be removed once Popover is merged into core in v5.0\n      var dismissElementV1 = eventTarget.closest(\".\".concat(Classes.POPOVER_DISMISS, \", .\").concat(Classes.POPOVER_DISMISS_OVERRIDE));\n      var shouldDismiss = (_d = (_c = dismissElement === null || dismissElement === void 0 ? void 0 : dismissElement.classList.contains(Classes.POPOVER_DISMISS)) !== null && _c !== void 0 ? _c : dismissElementV1 === null || dismissElementV1 === void 0 ? void 0 : dismissElementV1.classList.contains(Classes.POPOVER_DISMISS)) !== null && _d !== void 0 ? _d : false;\n      var isDisabled = eventTarget.closest(\":disabled, .\".concat(Classes.DISABLED)) != null;\n      if (shouldDismiss && !isDisabled && (!isEventPopoverCapturing || isEventFromSelf)) {\n        _this.setOpenState(false, e);\n      }\n    };\n    _this.handleOverlayClose = function (e) {\n      var _a;\n      if (_this.targetRef.current == null || e === undefined) {\n        return;\n      }\n      var event = (_a = e.nativeEvent) !== null && _a !== void 0 ? _a : e;\n      var eventTarget = event.composed ? event.composedPath()[0] : event.target;\n      // if click was in target, target event listener will handle things, so don't close\n      if (!Utils.elementIsOrContains(_this.targetRef.current, eventTarget) || e.nativeEvent instanceof KeyboardEvent) {\n        _this.setOpenState(false, e);\n      }\n    };\n    _this.handleKeyDown = function (e) {\n      var isKeyboardClick = Utils.isKeyboardClick(e);\n      // For keyboard accessibility, trigger the same behavior as a click event upon pressing ENTER/SPACE\n      if (isKeyboardClick) {\n        _this.handleTargetClick(e);\n      }\n    };\n    _this.handleTargetClick = function (e) {\n      // Target element(s) may fire simulated click event upon pressing ENTER/SPACE, which we should ignore\n      // see: https://github.com/palantir/blueprint/issues/5775\n      var shouldIgnoreClick = _this.state.isOpen && _this.isSimulatedButtonClick(e);\n      if (!shouldIgnoreClick) {\n        // ensure click did not originate from within inline popover before closing\n        if (!_this.props.disabled && !_this.isElementInPopover(e.target)) {\n          if (_this.props.isOpen == null) {\n            _this.setState(function (prevState) {\n              return {\n                isOpen: !prevState.isOpen\n              };\n            });\n          } else {\n            _this.setOpenState(!_this.props.isOpen, e);\n          }\n        }\n      }\n    };\n    _this.isSimulatedButtonClick = function (e) {\n      return !e.isTrusted && e.target.matches(\".\".concat(Classes.BUTTON));\n    };\n    return _this;\n  }\n  // popper innerRef gives us a handle on the transition container, since that's what we render as the overlay child,\n  // so if we want to look at our actual popover element, we need to reach inside a bit\n  Popover.prototype.getPopoverElement = function () {\n    var _a;\n    return (_a = this.popoverElement) === null || _a === void 0 ? void 0 : _a.querySelector(\".\".concat(Classes.POPOVER));\n  };\n  Popover.prototype.getIsOpen = function (props) {\n    var _a;\n    // disabled popovers should never be allowed to open.\n    if (props.disabled) {\n      return false;\n    } else {\n      return (_a = props.isOpen) !== null && _a !== void 0 ? _a : props.defaultIsOpen;\n    }\n  };\n  Popover.prototype.render = function () {\n    var _a = this.props,\n      disabled = _a.disabled,\n      content = _a.content,\n      placement = _a.placement,\n      _b = _a.position,\n      position = _b === void 0 ? \"auto\" : _b,\n      positioningStrategy = _a.positioningStrategy;\n    var isOpen = this.state.isOpen;\n    var isContentEmpty = content == null || typeof content === \"string\" && content.trim() === \"\";\n    if (isContentEmpty) {\n      // need to do this check in render(), because `isOpen` is derived from\n      // state, and state can't necessarily be accessed in validateProps.\n      if (!disabled && isOpen !== false && !Utils.isNodeEnv(\"production\")) {\n        console.warn(Errors.POPOVER_WARN_EMPTY_CONTENT);\n      }\n      // just render the target without a content overlay if there is no content to display\n      return this.renderTarget({\n        ref: noop\n      });\n    }\n    return React.createElement(Manager, null, React.createElement(Reference, {\n      innerRef: this.targetRef\n    }, this.renderTarget), React.createElement(Popper, {\n      innerRef: this.popoverRef,\n      placement: placement !== null && placement !== void 0 ? placement : positionToPlacement(position),\n      strategy: positioningStrategy,\n      modifiers: this.getPopperModifiers()\n    }, this.renderPopover));\n  };\n  Popover.prototype.componentDidMount = function () {\n    this.updateDarkParent();\n  };\n  Popover.prototype.componentDidUpdate = function (props, state) {\n    _super.prototype.componentDidUpdate.call(this, props, state);\n    this.updateDarkParent();\n    var nextIsOpen = this.getIsOpen(this.props);\n    if (this.props.isOpen != null && nextIsOpen !== this.state.isOpen) {\n      this.setOpenState(nextIsOpen);\n      // tricky: setOpenState calls setState only if this.props.isOpen is\n      // not controlled, so we need to invoke setState manually here.\n      this.setState({\n        isOpen: nextIsOpen\n      });\n    } else if (this.props.disabled && this.state.isOpen && this.props.isOpen == null) {\n      // special case: close an uncontrolled popover when disabled is set to true\n      this.setOpenState(false);\n    }\n  };\n  Popover.prototype.validateProps = function (props) {\n    if (props.isOpen == null && props.onInteraction != null) {\n      console.warn(Errors.POPOVER_WARN_UNCONTROLLED_ONINTERACTION);\n    }\n    if (props.hasBackdrop && !props.usePortal) {\n      console.warn(Errors.POPOVER_WARN_HAS_BACKDROP_INLINE);\n    }\n    if (props.hasBackdrop && props.interactionKind !== PopoverInteractionKind.CLICK) {\n      console.warn(Errors.POPOVER_HAS_BACKDROP_INTERACTION);\n    }\n    if (props.placement !== undefined && props.position !== undefined) {\n      console.warn(Errors.POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX);\n    }\n    var childrenCount = React.Children.count(props.children);\n    var hasRenderTargetProp = props.renderTarget !== undefined;\n    var hasTargetPropsProp = props.targetProps !== undefined;\n    if (childrenCount === 0 && !hasRenderTargetProp) {\n      console.warn(Errors.POPOVER_REQUIRES_TARGET);\n    }\n    if (childrenCount > 1) {\n      console.warn(Errors.POPOVER_WARN_TOO_MANY_CHILDREN);\n    }\n    if (childrenCount > 0 && hasRenderTargetProp) {\n      console.warn(Errors.POPOVER_WARN_DOUBLE_TARGET);\n    }\n    if (hasRenderTargetProp && hasTargetPropsProp) {\n      console.warn(Errors.POPOVER_WARN_TARGET_PROPS_WITH_RENDER_TARGET);\n    }\n  };\n  Popover.prototype.getPopperModifiers = function () {\n    var _a, _b, _c, _d;\n    var _e = this.props,\n      matchTargetWidth = _e.matchTargetWidth,\n      modifiers = _e.modifiers,\n      modifiersCustom = _e.modifiersCustom;\n    var popperModifiers = [__assign({\n      enabled: this.isArrowEnabled(),\n      name: \"arrow\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.arrow), __assign(__assign({\n      name: \"computeStyles\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.computeStyles), {\n      options: __assign({\n        adaptive: true,\n        // We disable the built-in gpuAcceleration so that\n        // Popper.js will return us easy to interpolate values\n        // (top, left instead of transform: translate3d)\n        // We'll then use these values to generate the needed\n        // css transform values blended with the react-spring values\n        gpuAcceleration: false\n      }, (_a = modifiers === null || modifiers === void 0 ? void 0 : modifiers.computeStyles) === null || _a === void 0 ? void 0 : _a.options)\n    }), __assign(__assign({\n      enabled: this.isArrowEnabled(),\n      name: \"offset\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.offset), {\n      options: __assign({\n        offset: [0, POPOVER_ARROW_SVG_SIZE / 2]\n      }, (_b = modifiers === null || modifiers === void 0 ? void 0 : modifiers.offset) === null || _b === void 0 ? void 0 : _b.options)\n    }), __assign(__assign({\n      name: \"flip\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.flip), {\n      options: __assign({\n        boundary: this.props.boundary,\n        rootBoundary: this.props.rootBoundary\n      }, (_c = modifiers === null || modifiers === void 0 ? void 0 : modifiers.flip) === null || _c === void 0 ? void 0 : _c.options)\n    }), __assign(__assign({\n      name: \"preventOverflow\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.preventOverflow), {\n      options: __assign({\n        boundary: this.props.boundary,\n        rootBoundary: this.props.rootBoundary\n      }, (_d = modifiers === null || modifiers === void 0 ? void 0 : modifiers.preventOverflow) === null || _d === void 0 ? void 0 : _d.options)\n    })];\n    if (matchTargetWidth) {\n      popperModifiers.push(matchReferenceWidthModifier);\n    }\n    if (modifiersCustom !== undefined) {\n      popperModifiers.push.apply(popperModifiers, modifiersCustom);\n    }\n    return popperModifiers;\n  };\n  // a wrapper around setState({ isOpen }) that will call props.onInteraction instead when in controlled mode.\n  // starts a timeout to delay changing the state if a non-zero duration is provided.\n  Popover.prototype.setOpenState = function (isOpen, e, timeout) {\n    var _this = this;\n    var _a, _b, _c, _d, _e;\n    // cancel any existing timeout because we have new state\n    (_a = this.cancelOpenTimeout) === null || _a === void 0 ? void 0 : _a.call(this);\n    if (timeout !== undefined && timeout > 0) {\n      this.cancelOpenTimeout = this.setTimeout(function () {\n        return _this.setOpenState(isOpen, e);\n      }, timeout);\n    } else {\n      if (this.props.isOpen == null) {\n        this.setState({\n          isOpen: isOpen\n        });\n      } else {\n        (_c = (_b = this.props).onInteraction) === null || _c === void 0 ? void 0 : _c.call(_b, isOpen, e);\n      }\n      if (!isOpen) {\n        // non-null assertion because the only time `e` is undefined is when in controlled mode\n        // or the rare special case in uncontrolled mode when the `disabled` flag is toggled true\n        (_e = (_d = this.props).onClose) === null || _e === void 0 ? void 0 : _e.call(_d, e);\n      }\n    }\n  };\n  Popover.prototype.updateDarkParent = function () {\n    if (this.props.usePortal && this.state.isOpen) {\n      var hasDarkParent = this.targetRef.current != null && this.targetRef.current.closest(\".\".concat(Classes.DARK)) != null;\n      this.setState({\n        hasDarkParent: hasDarkParent\n      });\n    }\n  };\n  Popover.prototype.isElementInPopover = function (element) {\n    var _a, _b;\n    return (_b = (_a = this.getPopoverElement()) === null || _a === void 0 ? void 0 : _a.contains(element)) !== null && _b !== void 0 ? _b : false;\n  };\n  Popover.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".Popover\");\n  Popover.defaultProps = {\n    boundary: \"clippingParents\",\n    captureDismiss: false,\n    defaultIsOpen: false,\n    disabled: false,\n    fill: false,\n    hasBackdrop: false,\n    hoverCloseDelay: 300,\n    hoverOpenDelay: 150,\n    inheritDarkTheme: true,\n    interactionKind: PopoverInteractionKind.CLICK,\n    matchTargetWidth: false,\n    minimal: false,\n    openOnTargetFocus: true,\n    // N.B. we don't set a default for `placement` or `position` here because that would trigger\n    // a warning in validateProps if the other prop is specified by a user of this component\n    positioningStrategy: \"absolute\",\n    renderTarget: undefined,\n    shouldReturnFocusOnClose: false,\n    targetTagName: \"span\",\n    transitionDuration: 300,\n    usePortal: true\n  };\n  return Popover;\n}(AbstractPureComponent);\nexport { Popover };\nfunction noop() {\n  // no-op\n}","map":{"version":3,"names":["classNames","React","Manager","Popper","Reference","AbstractPureComponent","Classes","DISPLAYNAME_PREFIX","refHandler","Utils","Errors","Overlay","ResizeSensor","Tooltip","matchReferenceWidthModifier","POPOVER_ARROW_SVG_SIZE","PopoverArrow","positionToPlacement","getBasePlacement","getTransformOrigin","PopoverInteractionKind","CLICK","CLICK_TARGET_ONLY","HOVER","HOVER_TARGET_ONLY","Popover","_super","__extends","_this","apply","arguments","state","hasDarkParent","isOpen","getIsOpen","props","popoverElement","popoverRef","targetRef","createRef","isMouseInTargetOrPopover","lostFocusOnSamePage","isControlled","undefined","isArrowEnabled","_a","_b","minimal","modifiers","arrow","enabled","isHoverInteractionKind","interactionKind","reposition","popperScheduleUpdate","call","renderTarget","ref","_f","children","className","fill","openOnTargetFocus","targetTagName","targetEventHandlers","onBlur","handleTargetBlur","onContextMenu","handleTargetContextMenu","onFocus","handleTargetFocus","onMouseEnter","handleMouseEnter","onMouseLeave","handleMouseLeave","onClick","handleTargetClick","onKeyDown","handleKeyDown","targetTabIndex","ownTargetProps","__assign","_d","popupKind","POPOVER_TARGET","POPOVER_OPEN","ACTIVE","targetModifierClasses","_c","FILL","target","tabIndex","childTarget","ensureElement","Children","toArray","clonedTarget","cloneElement","disabled","isElementOfType","_e","wrappedTarget","createElement","targetProps","onResize","renderPopover","popperProps","shouldReturnFocusOnClose","usePortal","transformOrigin","placement","arrowProps","style","update","popoverHandlers","handlePopoverClick","event","isKeyboardClick","basePlacement","popoverClasses","POPOVER","DARK","inheritDarkTheme","MINIMAL","POPOVER_CAPTURING_DISMISS","captureDismiss","POPOVER_MATCH_TARGET_WIDTH","matchTargetWidth","POPOVER_REFERENCE_HIDDEN","isReferenceHidden","POPOVER_POPPER_ESCAPED","hasPopperEscaped","concat","POPOVER_CONTENT_PLACEMENT","popoverClassName","defaultAutoFocus","autoFocus","backdropClassName","POPOVER_BACKDROP","backdropProps","canEscapeKeyClose","canOutsideClickClose","enforceFocus","hasBackdrop","onClose","handleOverlayClose","onClosed","onClosing","onOpened","onOpening","transitionDuration","transitionName","portalClassName","portalContainer","POPOVER_TRANSITION_CONTAINER","POPOVER_CONTENT","content","e","relatedTarget","isElementInPopover","defaultPrevented","setOpenState","hoverOpenDelay","setTimeout","hoverCloseDelay","eventTarget","eventPopover","closest","eventPopoverV1","isEventFromSelf","getPopoverElement","isEventPopoverCapturing","classList","contains","dismissElement","POPOVER_DISMISS","POPOVER_DISMISS_OVERRIDE","dismissElementV1","shouldDismiss","isDisabled","DISABLED","current","nativeEvent","composed","composedPath","elementIsOrContains","KeyboardEvent","shouldIgnoreClick","isSimulatedButtonClick","setState","prevState","isTrusted","matches","BUTTON","prototype","querySelector","defaultIsOpen","render","position","positioningStrategy","isContentEmpty","trim","isNodeEnv","console","warn","POPOVER_WARN_EMPTY_CONTENT","noop","innerRef","strategy","getPopperModifiers","componentDidMount","updateDarkParent","componentDidUpdate","nextIsOpen","validateProps","onInteraction","POPOVER_WARN_UNCONTROLLED_ONINTERACTION","POPOVER_WARN_HAS_BACKDROP_INLINE","POPOVER_HAS_BACKDROP_INTERACTION","POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX","childrenCount","count","hasRenderTargetProp","hasTargetPropsProp","POPOVER_REQUIRES_TARGET","POPOVER_WARN_TOO_MANY_CHILDREN","POPOVER_WARN_DOUBLE_TARGET","POPOVER_WARN_TARGET_PROPS_WITH_RENDER_TARGET","modifiersCustom","popperModifiers","name","computeStyles","options","adaptive","gpuAcceleration","offset","flip","boundary","rootBoundary","preventOverflow","push","timeout","cancelOpenTimeout","element","displayName","defaultProps"],"sources":["/home/meander/Desktop/Akash/Workit/my-app/node_modules/@blueprintjs/core/src/components/popover/popover.tsx"],"sourcesContent":["/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { State as PopperState, PositioningStrategy } from \"@popperjs/core\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { Manager, Modifier, Popper, PopperChildrenProps, Reference, ReferenceChildrenProps } from \"react-popper\";\n\nimport { AbstractPureComponent, Classes, DISPLAYNAME_PREFIX, HTMLDivProps, refHandler, Utils } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { Overlay } from \"../overlay/overlay\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\";\n// eslint-disable-next-line import/no-cycle\nimport { Tooltip } from \"../tooltip/tooltip\";\nimport { matchReferenceWidthModifier } from \"./customModifiers\";\nimport { POPOVER_ARROW_SVG_SIZE, PopoverArrow } from \"./popoverArrow\";\nimport { positionToPlacement } from \"./popoverPlacementUtils\";\nimport {\n    DefaultPopoverTargetHTMLProps,\n    PopoverClickTargetHandlers,\n    PopoverHoverTargetHandlers,\n    PopoverSharedProps,\n} from \"./popoverSharedProps\";\nimport { getBasePlacement, getTransformOrigin } from \"./popperUtils\";\nimport { PopupKind } from \"./popupKind\";\n\nexport const PopoverInteractionKind = {\n    CLICK: \"click\" as \"click\",\n    CLICK_TARGET_ONLY: \"click-target\" as \"click-target\",\n    HOVER: \"hover\" as \"hover\",\n    HOVER_TARGET_ONLY: \"hover-target\" as \"hover-target\",\n};\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport type PopoverInteractionKind = (typeof PopoverInteractionKind)[keyof typeof PopoverInteractionKind];\n\nexport interface PopoverProps<TProps extends DefaultPopoverTargetHTMLProps = DefaultPopoverTargetHTMLProps>\n    extends PopoverSharedProps<TProps> {\n    /**\n     * Whether the popover/tooltip should acquire application focus when it first opens.\n     *\n     * @default true for click interactions, false for hover interactions\n     */\n    autoFocus?: boolean;\n\n    /** HTML props for the backdrop element. Can be combined with `backdropClassName`. */\n    backdropProps?: React.HTMLProps<HTMLDivElement>;\n\n    /**\n     * The content displayed inside the popover.\n     */\n    content?: string | JSX.Element;\n\n    /**\n     * The kind of interaction that triggers the display of the popover.\n     *\n     * @default \"click\"\n     */\n    interactionKind?: PopoverInteractionKind;\n\n    /**\n     * The kind of popup displayed by the popover. This property is ignored if\n     * `interactionKind` is {@link PopoverInteractionKind.HOVER_TARGET_ONLY}.\n     * This controls the `aria-haspopup` attribute of the target element. The\n     * default is \"menu\" (technically, `aria-haspopup` will be set to \"true\",\n     * which is the same as \"menu\", for backwards compatibility).\n     *\n     * @default \"menu\" or undefined\n     */\n    popupKind?: PopupKind;\n\n    /**\n     * Enables an invisible overlay beneath the popover that captures clicks and\n     * prevents interaction with the rest of the document until the popover is\n     * closed. This prop is only available when `interactionKind` is\n     * `PopoverInteractionKind.CLICK`. When popovers with backdrop are opened,\n     * they become focused.\n     *\n     * @default false\n     */\n    hasBackdrop?: boolean;\n\n    /**\n     * Whether the application should return focus to the last active element in the\n     * document after this popover closes.\n     *\n     * This is automatically set to `false` if this is a hover interaction popover.\n     *\n     * If you are attaching a popover _and_ a tooltip to the same target, you must take\n     * care to either disable this prop for the popover _or_ disable the tooltip's\n     * `openOnTargetFocus` prop.\n     *\n     * @default false\n     */\n    shouldReturnFocusOnClose?: boolean;\n\n    /**\n     * Popper.js positioning strategy.\n     *\n     * @see https://popper.js.org/docs/v2/constructors/#strategy\n     * @default \"absolute\"\n     */\n    positioningStrategy?: PositioningStrategy;\n}\n\nexport interface PopoverState {\n    isOpen: boolean;\n    hasDarkParent: boolean;\n}\n\n/**\n * Popover component, used to display a floating UI next to and tethered to a target element.\n *\n * @template T target element props interface. Consumers wishing to stay in sync with Blueprint's default target HTML\n * props interface should use the `DefaultPopoverTargetHTMLProps` type (although this is already the default type for\n * this type param).\n * @see https://blueprintjs.com/docs/#core/components/popover\n */\nexport class Popover<\n    T extends DefaultPopoverTargetHTMLProps = DefaultPopoverTargetHTMLProps,\n> extends AbstractPureComponent<PopoverProps<T>, PopoverState> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.Popover`;\n\n    public static defaultProps: PopoverProps = {\n        boundary: \"clippingParents\",\n        captureDismiss: false,\n        defaultIsOpen: false,\n        disabled: false,\n        fill: false,\n        hasBackdrop: false,\n        hoverCloseDelay: 300,\n        hoverOpenDelay: 150,\n        inheritDarkTheme: true,\n        interactionKind: PopoverInteractionKind.CLICK,\n        matchTargetWidth: false,\n        minimal: false,\n        openOnTargetFocus: true,\n        // N.B. we don't set a default for `placement` or `position` here because that would trigger\n        // a warning in validateProps if the other prop is specified by a user of this component\n        positioningStrategy: \"absolute\",\n        renderTarget: undefined,\n        shouldReturnFocusOnClose: false,\n        targetTagName: \"span\",\n        transitionDuration: 300,\n        usePortal: true,\n    };\n\n    public state: PopoverState = {\n        hasDarkParent: false,\n        isOpen: this.getIsOpen(this.props),\n    };\n\n    /**\n     * DOM element that contains the popover.\n     * When `usePortal={true}`, this element will be portaled outside the usual DOM flow,\n     * so this reference can be very useful for testing.\n     *\n     * @public for testing\n     */\n    public popoverElement: HTMLElement | null = null;\n\n    /** Popover ref handler */\n    private popoverRef: React.Ref<HTMLDivElement> = refHandler(this, \"popoverElement\", this.props.popoverRef);\n\n    /**\n     * Target DOM element ref.\n     *\n     * @public for testing\n     */\n    public targetRef = React.createRef<HTMLElement>();\n\n    private cancelOpenTimeout?: () => void;\n\n    // a flag that lets us detect mouse movement between the target and popover,\n    // now that mouseleave is triggered when you cross the gap between the two.\n    private isMouseInTargetOrPopover = false;\n\n    // a flag that indicates whether the target previously lost focus to another\n    // element on the same page.\n    private lostFocusOnSamePage = true;\n\n    // Reference to the Poppper.scheduleUpdate() function, this changes every time the popper is mounted\n    private popperScheduleUpdate?: () => Promise<Partial<PopperState> | null>;\n\n    private isControlled = () => this.props.isOpen !== undefined;\n\n    // arrow is disabled if minimal, or if the arrow modifier was explicitly disabled\n    private isArrowEnabled = () => !this.props.minimal && this.props.modifiers?.arrow?.enabled !== false;\n\n    private isHoverInteractionKind = () => {\n        return (\n            this.props.interactionKind === PopoverInteractionKind.HOVER ||\n            this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY\n        );\n    };\n\n    // popper innerRef gives us a handle on the transition container, since that's what we render as the overlay child,\n    // so if we want to look at our actual popover element, we need to reach inside a bit\n    private getPopoverElement() {\n        return this.popoverElement?.querySelector<HTMLElement>(`.${Classes.POPOVER}`);\n    }\n\n    private getIsOpen(props: PopoverProps<T>) {\n        // disabled popovers should never be allowed to open.\n        if (props.disabled) {\n            return false;\n        } else {\n            return props.isOpen ?? props.defaultIsOpen!;\n        }\n    }\n\n    public render() {\n        const { disabled, content, placement, position = \"auto\", positioningStrategy } = this.props;\n        const { isOpen } = this.state;\n\n        const isContentEmpty = content == null || (typeof content === \"string\" && content.trim() === \"\");\n        if (isContentEmpty) {\n            // need to do this check in render(), because `isOpen` is derived from\n            // state, and state can't necessarily be accessed in validateProps.\n            if (!disabled && isOpen !== false && !Utils.isNodeEnv(\"production\")) {\n                console.warn(Errors.POPOVER_WARN_EMPTY_CONTENT);\n            }\n            // just render the target without a content overlay if there is no content to display\n            return this.renderTarget({ ref: noop });\n        }\n\n        return (\n            <Manager>\n                <Reference innerRef={this.targetRef}>{this.renderTarget}</Reference>\n                <Popper\n                    innerRef={this.popoverRef}\n                    placement={placement ?? positionToPlacement(position)}\n                    strategy={positioningStrategy}\n                    modifiers={this.getPopperModifiers()}\n                >\n                    {this.renderPopover}\n                </Popper>\n            </Manager>\n        );\n    }\n\n    public componentDidMount() {\n        this.updateDarkParent();\n    }\n\n    public componentDidUpdate(props: PopoverProps<T>, state: PopoverState) {\n        super.componentDidUpdate(props, state);\n        this.updateDarkParent();\n\n        const nextIsOpen = this.getIsOpen(this.props);\n\n        if (this.props.isOpen != null && nextIsOpen !== this.state.isOpen) {\n            this.setOpenState(nextIsOpen);\n            // tricky: setOpenState calls setState only if this.props.isOpen is\n            // not controlled, so we need to invoke setState manually here.\n            this.setState({ isOpen: nextIsOpen });\n        } else if (this.props.disabled && this.state.isOpen && this.props.isOpen == null) {\n            // special case: close an uncontrolled popover when disabled is set to true\n            this.setOpenState(false);\n        }\n    }\n\n    protected validateProps(props: PopoverProps<T> & { children?: React.ReactNode }) {\n        if (props.isOpen == null && props.onInteraction != null) {\n            console.warn(Errors.POPOVER_WARN_UNCONTROLLED_ONINTERACTION);\n        }\n        if (props.hasBackdrop && !props.usePortal) {\n            console.warn(Errors.POPOVER_WARN_HAS_BACKDROP_INLINE);\n        }\n        if (props.hasBackdrop && props.interactionKind !== PopoverInteractionKind.CLICK) {\n            console.warn(Errors.POPOVER_HAS_BACKDROP_INTERACTION);\n        }\n        if (props.placement !== undefined && props.position !== undefined) {\n            console.warn(Errors.POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX);\n        }\n\n        const childrenCount = React.Children.count(props.children);\n        const hasRenderTargetProp = props.renderTarget !== undefined;\n        const hasTargetPropsProp = props.targetProps !== undefined;\n\n        if (childrenCount === 0 && !hasRenderTargetProp) {\n            console.warn(Errors.POPOVER_REQUIRES_TARGET);\n        }\n        if (childrenCount > 1) {\n            console.warn(Errors.POPOVER_WARN_TOO_MANY_CHILDREN);\n        }\n        if (childrenCount > 0 && hasRenderTargetProp) {\n            console.warn(Errors.POPOVER_WARN_DOUBLE_TARGET);\n        }\n        if (hasRenderTargetProp && hasTargetPropsProp) {\n            console.warn(Errors.POPOVER_WARN_TARGET_PROPS_WITH_RENDER_TARGET);\n        }\n    }\n\n    /**\n     * Instance method to instruct the `Popover` to recompute its position.\n     *\n     * This method should only be used if you are updating the target in a way\n     * that does not cause it to re-render, such as changing its _position_\n     * without changing its _size_ (since `Popover` already repositions when it\n     * detects a resize).\n     */\n    public reposition = () => this.popperScheduleUpdate?.();\n\n    private renderTarget = ({ ref }: ReferenceChildrenProps) => {\n        const { children, className, fill, openOnTargetFocus, renderTarget } = this.props;\n        const { isOpen } = this.state;\n        const isControlled = this.isControlled();\n        const isHoverInteractionKind = this.isHoverInteractionKind();\n\n        let { targetTagName } = this.props;\n        if (fill) {\n            targetTagName = \"div\";\n        }\n\n        const targetEventHandlers: PopoverHoverTargetHandlers<T> | PopoverClickTargetHandlers<T> =\n            isHoverInteractionKind\n                ? {\n                      // HOVER handlers\n                      onBlur: this.handleTargetBlur,\n                      onContextMenu: this.handleTargetContextMenu,\n                      onFocus: this.handleTargetFocus,\n                      onMouseEnter: this.handleMouseEnter,\n                      onMouseLeave: this.handleMouseLeave,\n                  }\n                : {\n                      // CLICK needs only one handler\n                      onClick: this.handleTargetClick,\n                      // For keyboard accessibility, trigger the same behavior as a click event upon pressing ENTER/SPACE\n                      onKeyDown: this.handleKeyDown,\n                  };\n        // Ensure target is focusable if relevant prop enabled\n        const targetTabIndex = openOnTargetFocus && isHoverInteractionKind ? 0 : undefined;\n        const ownTargetProps = {\n            \"aria-haspopup\":\n                this.props.popupKind ??\n                (this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY\n                    ? undefined\n                    : (\"true\" as \"true\")),\n            // N.B. this.props.className is passed along to renderTarget even though the user would have access to it.\n            // If, instead, renderTarget is undefined and the target is provided as a child, this.props.className is\n            // applied to the generated target wrapper element.\n            className: classNames(className, Classes.POPOVER_TARGET, {\n                [Classes.POPOVER_OPEN]: isOpen,\n                // this class is mainly useful for button targets\n                [Classes.ACTIVE]: isOpen && !isControlled && !isHoverInteractionKind,\n            }),\n            ref,\n            ...targetEventHandlers,\n        };\n\n        const targetModifierClasses = {\n            // this class is mainly useful for Blueprint <Button> targets; we should only apply it for\n            // uncontrolled popovers when they are opened by a user interaction\n            [Classes.ACTIVE]: isOpen && !isControlled && !isHoverInteractionKind,\n            // similarly, this class is mainly useful for targets like <Button>, <InputGroup>, etc.\n            [Classes.FILL]: fill,\n        };\n\n        let target: JSX.Element | undefined;\n\n        if (renderTarget !== undefined) {\n            target = renderTarget({\n                ...ownTargetProps,\n                className: classNames(ownTargetProps.className, targetModifierClasses),\n                // if the consumer renders a tooltip target, it's their responsibility to disable that tooltip\n                // when *this* popover is open\n                isOpen,\n                tabIndex: targetTabIndex,\n            });\n        } else {\n            const childTarget = Utils.ensureElement(React.Children.toArray(children)[0])!;\n\n            if (childTarget === undefined) {\n                return null;\n            }\n\n            const clonedTarget: JSX.Element = React.cloneElement(childTarget, {\n                className: classNames(childTarget.props.className, targetModifierClasses),\n                // force disable single Tooltip child when popover is open\n                disabled: isOpen && Utils.isElementOfType(childTarget, Tooltip) ? true : childTarget.props.disabled,\n                tabIndex: childTarget.props.tabIndex ?? targetTabIndex,\n            });\n            const wrappedTarget = React.createElement(\n                targetTagName!,\n                {\n                    ...ownTargetProps,\n                    ...this.props.targetProps,\n                },\n                clonedTarget,\n            );\n            target = wrappedTarget;\n        }\n\n        // N.B. we must attach the ref ('wrapped' with react-popper functionality) to the DOM element here and\n        // let ResizeSensor know about it\n        return (\n            <ResizeSensor targetRef={this.targetRef} onResize={this.reposition}>\n                {target}\n            </ResizeSensor>\n        );\n    };\n\n    private renderPopover = (popperProps: PopperChildrenProps) => {\n        const { interactionKind, shouldReturnFocusOnClose, usePortal } = this.props;\n        const { isOpen } = this.state;\n\n        // compute an appropriate transform origin so the scale animation points towards target\n        const transformOrigin = getTransformOrigin(\n            popperProps.placement,\n            this.isArrowEnabled() ? (popperProps.arrowProps.style as any) : undefined,\n        );\n\n        // need to update our reference to this function on every render as it will change.\n        this.popperScheduleUpdate = popperProps.update;\n\n        const popoverHandlers: HTMLDivProps = {\n            // always check popover clicks for dismiss class\n            onClick: this.handlePopoverClick,\n            // treat ENTER/SPACE keys the same as a click for accessibility\n            onKeyDown: event => Utils.isKeyboardClick(event) && this.handlePopoverClick(event),\n        };\n        if (\n            interactionKind === PopoverInteractionKind.HOVER ||\n            (!usePortal && interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY)\n        ) {\n            popoverHandlers.onMouseEnter = this.handleMouseEnter;\n            popoverHandlers.onMouseLeave = this.handleMouseLeave;\n        }\n\n        const basePlacement = getBasePlacement(popperProps.placement);\n        const popoverClasses = classNames(\n            Classes.POPOVER,\n            {\n                [Classes.DARK]: this.props.inheritDarkTheme && this.state.hasDarkParent,\n                [Classes.MINIMAL]: this.props.minimal,\n                [Classes.POPOVER_CAPTURING_DISMISS]: this.props.captureDismiss,\n                [Classes.POPOVER_MATCH_TARGET_WIDTH]: this.props.matchTargetWidth,\n                [Classes.POPOVER_REFERENCE_HIDDEN]: popperProps.isReferenceHidden === true,\n                [Classes.POPOVER_POPPER_ESCAPED]: popperProps.hasPopperEscaped === true,\n            },\n            `${Classes.POPOVER_CONTENT_PLACEMENT}-${basePlacement}`,\n            this.props.popoverClassName,\n        );\n\n        const defaultAutoFocus = this.isHoverInteractionKind() ? false : undefined;\n\n        return (\n            <Overlay\n                autoFocus={this.props.autoFocus ?? defaultAutoFocus}\n                backdropClassName={Classes.POPOVER_BACKDROP}\n                backdropProps={this.props.backdropProps}\n                canEscapeKeyClose={this.props.canEscapeKeyClose}\n                canOutsideClickClose={this.props.interactionKind === PopoverInteractionKind.CLICK}\n                enforceFocus={this.props.enforceFocus}\n                hasBackdrop={this.props.hasBackdrop}\n                isOpen={isOpen}\n                onClose={this.handleOverlayClose}\n                onClosed={this.props.onClosed}\n                onClosing={this.props.onClosing}\n                onOpened={this.props.onOpened}\n                onOpening={this.props.onOpening}\n                transitionDuration={this.props.transitionDuration}\n                transitionName={Classes.POPOVER}\n                usePortal={this.props.usePortal}\n                portalClassName={this.props.portalClassName}\n                portalContainer={this.props.portalContainer}\n                // if hover interaction, it doesn't make sense to take over focus control\n                shouldReturnFocusOnClose={this.isHoverInteractionKind() ? false : shouldReturnFocusOnClose}\n            >\n                <div className={Classes.POPOVER_TRANSITION_CONTAINER} ref={popperProps.ref} style={popperProps.style}>\n                    <ResizeSensor onResize={this.reposition}>\n                        <div\n                            className={popoverClasses}\n                            style={{ transformOrigin }}\n                            ref={this.popoverRef}\n                            {...popoverHandlers}\n                        >\n                            {this.isArrowEnabled() && (\n                                <PopoverArrow arrowProps={popperProps.arrowProps} placement={popperProps.placement} />\n                            )}\n                            <div className={Classes.POPOVER_CONTENT}>{this.props.content}</div>\n                        </div>\n                    </ResizeSensor>\n                </div>\n            </Overlay>\n        );\n    };\n\n    private getPopperModifiers(): ReadonlyArray<Modifier<any>> {\n        const { matchTargetWidth, modifiers, modifiersCustom } = this.props;\n        const popperModifiers: Array<Modifier<any>> = [\n            {\n                enabled: this.isArrowEnabled(),\n                name: \"arrow\",\n                ...modifiers?.arrow,\n            },\n            {\n                name: \"computeStyles\",\n                ...modifiers?.computeStyles,\n                options: {\n                    adaptive: true,\n                    // We disable the built-in gpuAcceleration so that\n                    // Popper.js will return us easy to interpolate values\n                    // (top, left instead of transform: translate3d)\n                    // We'll then use these values to generate the needed\n                    // css transform values blended with the react-spring values\n                    gpuAcceleration: false,\n                    ...modifiers?.computeStyles?.options,\n                },\n            },\n            {\n                enabled: this.isArrowEnabled(),\n                name: \"offset\",\n                ...modifiers?.offset,\n                options: {\n                    offset: [0, POPOVER_ARROW_SVG_SIZE / 2],\n                    ...modifiers?.offset?.options,\n                },\n            },\n            {\n                name: \"flip\",\n                ...modifiers?.flip,\n                options: {\n                    boundary: this.props.boundary,\n                    rootBoundary: this.props.rootBoundary,\n                    ...modifiers?.flip?.options,\n                },\n            },\n            {\n                name: \"preventOverflow\",\n                ...modifiers?.preventOverflow,\n                options: {\n                    boundary: this.props.boundary,\n                    rootBoundary: this.props.rootBoundary,\n                    ...modifiers?.preventOverflow?.options,\n                },\n            },\n        ];\n\n        if (matchTargetWidth) {\n            popperModifiers.push(matchReferenceWidthModifier);\n        }\n\n        if (modifiersCustom !== undefined) {\n            popperModifiers.push(...modifiersCustom);\n        }\n\n        return popperModifiers;\n    }\n\n    private handleTargetFocus = (e: React.FocusEvent<HTMLElement>) => {\n        if (this.props.openOnTargetFocus && this.isHoverInteractionKind()) {\n            if (e.relatedTarget == null && !this.lostFocusOnSamePage) {\n                // ignore this focus event -- the target was already focused but the page itself\n                // lost focus (e.g. due to switching tabs).\n                return;\n            }\n            this.handleMouseEnter(e as unknown as React.MouseEvent<HTMLElement>);\n        }\n    };\n\n    private handleTargetBlur = (e: React.FocusEvent<HTMLElement>) => {\n        if (this.props.openOnTargetFocus && this.isHoverInteractionKind()) {\n            if (e.relatedTarget != null) {\n                // if the next element to receive focus is within the popover, we'll want to leave the\n                // popover open.\n                if (\n                    e.relatedTarget !== this.popoverElement &&\n                    !this.isElementInPopover(e.relatedTarget as HTMLElement)\n                ) {\n                    this.handleMouseLeave(e as unknown as React.MouseEvent<HTMLElement>);\n                }\n            } else {\n                this.handleMouseLeave(e as unknown as React.MouseEvent<HTMLElement>);\n            }\n        }\n        this.lostFocusOnSamePage = e.relatedTarget != null;\n    };\n\n    private handleTargetContextMenu = (e: React.MouseEvent<HTMLElement>) => {\n        // we assume that when someone prevents the default interaction on this event (a browser native context menu),\n        // they are showing a custom context menu (as ContextMenu2 does); in this case, we should close this popover/tooltip\n        if (e.defaultPrevented) {\n            this.setOpenState(false, e);\n        }\n    };\n\n    private handleMouseEnter = (e: React.MouseEvent<HTMLElement>) => {\n        this.isMouseInTargetOrPopover = true;\n\n        // if we're entering the popover, and the mode is set to be HOVER_TARGET_ONLY, we want to manually\n        // trigger the mouse leave event, as hovering over the popover shouldn't count.\n        if (\n            !this.props.usePortal &&\n            this.isElementInPopover(e.target as Element) &&\n            this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY &&\n            !this.props.openOnTargetFocus\n        ) {\n            this.handleMouseLeave(e);\n        } else if (!this.props.disabled) {\n            // only begin opening popover when it is enabled\n            this.setOpenState(true, e, this.props.hoverOpenDelay);\n        }\n    };\n\n    private handleMouseLeave = (e: React.MouseEvent<HTMLElement>) => {\n        this.isMouseInTargetOrPopover = false;\n\n        // wait until the event queue is flushed, because we want to leave the\n        // popover open if the mouse entered the popover immediately after\n        // leaving the target (or vice versa).\n        this.setTimeout(() => {\n            if (this.isMouseInTargetOrPopover) {\n                return;\n            }\n            // user-configurable closing delay is helpful when moving mouse from target to popover\n            this.setOpenState(false, e, this.props.hoverCloseDelay);\n        });\n    };\n\n    private handlePopoverClick = (e: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>) => {\n        const eventTarget = e.target as HTMLElement;\n        const eventPopover = eventTarget.closest(`.${Classes.POPOVER}`);\n        const eventPopoverV1 = eventTarget.closest(`.${Classes.POPOVER}`);\n        const isEventFromSelf = (eventPopover ?? eventPopoverV1) === this.getPopoverElement();\n\n        const isEventPopoverCapturing =\n            eventPopover?.classList.contains(Classes.POPOVER_CAPTURING_DISMISS) ??\n            eventPopoverV1?.classList.contains(Classes.POPOVER_CAPTURING_DISMISS) ??\n            false;\n\n        // an OVERRIDE inside a DISMISS does not dismiss, and a DISMISS inside an OVERRIDE will dismiss.\n        const dismissElement = eventTarget.closest(`.${Classes.POPOVER_DISMISS}, .${Classes.POPOVER_DISMISS_OVERRIDE}`);\n        // dismiss selectors from the \"V1\" version of Popover in the core package\n        // we expect these to be rendered by MenuItem, which at this point has no knowledge of Popover\n        // this can be removed once Popover is merged into core in v5.0\n        const dismissElementV1 = eventTarget.closest(\n            `.${Classes.POPOVER_DISMISS}, .${Classes.POPOVER_DISMISS_OVERRIDE}`,\n        );\n\n        const shouldDismiss =\n            dismissElement?.classList.contains(Classes.POPOVER_DISMISS) ??\n            dismissElementV1?.classList.contains(Classes.POPOVER_DISMISS) ??\n            false;\n\n        const isDisabled = eventTarget.closest(`:disabled, .${Classes.DISABLED}`) != null;\n\n        if (shouldDismiss && !isDisabled && (!isEventPopoverCapturing || isEventFromSelf)) {\n            this.setOpenState(false, e);\n        }\n    };\n\n    private handleOverlayClose = (e?: React.SyntheticEvent<HTMLElement>) => {\n        if (this.targetRef.current == null || e === undefined) {\n            return;\n        }\n\n        const event = (e.nativeEvent ?? e) as Event;\n        const eventTarget = (event.composed ? event.composedPath()[0] : event.target) as HTMLElement;\n        // if click was in target, target event listener will handle things, so don't close\n        if (!Utils.elementIsOrContains(this.targetRef.current, eventTarget) || e.nativeEvent instanceof KeyboardEvent) {\n            this.setOpenState(false, e);\n        }\n    };\n\n    private handleKeyDown = (e: React.KeyboardEvent<HTMLElement>) => {\n        const isKeyboardClick = Utils.isKeyboardClick(e);\n\n        // For keyboard accessibility, trigger the same behavior as a click event upon pressing ENTER/SPACE\n        if (isKeyboardClick) {\n            this.handleTargetClick(e);\n        }\n    };\n\n    private handleTargetClick = (e: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>) => {\n        // Target element(s) may fire simulated click event upon pressing ENTER/SPACE, which we should ignore\n        // see: https://github.com/palantir/blueprint/issues/5775\n        const shouldIgnoreClick = this.state.isOpen && this.isSimulatedButtonClick(e);\n        if (!shouldIgnoreClick) {\n            // ensure click did not originate from within inline popover before closing\n            if (!this.props.disabled && !this.isElementInPopover(e.target as HTMLElement)) {\n                if (this.props.isOpen == null) {\n                    this.setState(prevState => ({ isOpen: !prevState.isOpen }));\n                } else {\n                    this.setOpenState(!this.props.isOpen, e);\n                }\n            }\n        }\n    };\n\n    private isSimulatedButtonClick = (e: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>) => {\n        return !e.isTrusted && (e.target as HTMLElement).matches(`.${Classes.BUTTON}`);\n    };\n\n    // a wrapper around setState({ isOpen }) that will call props.onInteraction instead when in controlled mode.\n    // starts a timeout to delay changing the state if a non-zero duration is provided.\n    private setOpenState(isOpen: boolean, e?: React.SyntheticEvent<HTMLElement>, timeout?: number) {\n        // cancel any existing timeout because we have new state\n        this.cancelOpenTimeout?.();\n        if (timeout !== undefined && timeout > 0) {\n            this.cancelOpenTimeout = this.setTimeout(() => this.setOpenState(isOpen, e), timeout);\n        } else {\n            if (this.props.isOpen == null) {\n                this.setState({ isOpen });\n            } else {\n                this.props.onInteraction?.(isOpen, e);\n            }\n            if (!isOpen) {\n                // non-null assertion because the only time `e` is undefined is when in controlled mode\n                // or the rare special case in uncontrolled mode when the `disabled` flag is toggled true\n                this.props.onClose?.(e!);\n            }\n        }\n    }\n\n    private updateDarkParent() {\n        if (this.props.usePortal && this.state.isOpen) {\n            const hasDarkParent =\n                this.targetRef.current != null && this.targetRef.current.closest(`.${Classes.DARK}`) != null;\n            this.setState({ hasDarkParent });\n        }\n    }\n\n    private isElementInPopover(element: Element) {\n        return this.getPopoverElement()?.contains(element) ?? false;\n    }\n}\n\nfunction noop() {\n    // no-op\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}