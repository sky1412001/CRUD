{"ast":null,"code":"/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { AbstractPureComponent, Classes, DISPLAYNAME_PREFIX, Intent, Utils } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { Handle } from \"./handle\";\nimport { HandleInteractionKind, HandleType } from \"./handleProps\";\nimport { argMin, fillValues, formatPercentage } from \"./sliderUtils\";\n/**\n * SFC used to pass slider handle props to a `MultiSlider`.\n * This element is not rendered directly.\n */\nvar MultiSliderHandle = function () {\n  return null;\n};\nMultiSliderHandle.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".MultiSliderHandle\");\n/**\n * Multi slider component.\n *\n * @see https://blueprintjs.com/docs/#core/components/sliders.multi-slider\n */\nvar MultiSlider = /** @class */function (_super) {\n  __extends(MultiSlider, _super);\n  function MultiSlider() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.state = {\n      labelPrecision: getLabelPrecision(_this.props),\n      tickSize: 0,\n      tickSizeRatio: 0\n    };\n    _this.handleElements = [];\n    _this.trackElement = null;\n    _this.addHandleRef = function (ref) {\n      if (ref != null) {\n        _this.handleElements.push(ref);\n      }\n    };\n    _this.maybeHandleTrackClick = function (event) {\n      if (_this.canHandleTrackEvent(event)) {\n        var foundHandle = _this.nearestHandleForValue(_this.handleElements, function (handle) {\n          return handle.mouseEventClientOffset(event);\n        });\n        if (foundHandle) {\n          foundHandle.beginHandleMovement(event);\n        }\n      }\n    };\n    _this.maybeHandleTrackTouch = function (event) {\n      if (_this.canHandleTrackEvent(event)) {\n        var foundHandle = _this.nearestHandleForValue(_this.handleElements, function (handle) {\n          return handle.touchEventClientOffset(event);\n        });\n        if (foundHandle) {\n          foundHandle.beginHandleTouchMovement(event);\n        }\n      }\n    };\n    _this.canHandleTrackEvent = function (event) {\n      var target = event.target;\n      // ensure event does not come from inside the handle\n      return !_this.props.disabled && target.closest(\".\".concat(Classes.SLIDER_HANDLE)) == null;\n    };\n    _this.getHandlerForIndex = function (index, callback) {\n      return function (newValue) {\n        callback === null || callback === void 0 ? void 0 : callback(_this.getNewHandleValues(newValue, index));\n      };\n    };\n    _this.handleChange = function (newValues) {\n      var _a, _b;\n      var handleProps = getSortedInteractiveHandleProps(_this.props);\n      var oldValues = handleProps.map(function (handle) {\n        return handle.value;\n      });\n      if (!Utils.arraysEqual(newValues, oldValues)) {\n        (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, newValues);\n        handleProps.forEach(function (handle, index) {\n          var _a;\n          if (oldValues[index] !== newValues[index]) {\n            (_a = handle.onChange) === null || _a === void 0 ? void 0 : _a.call(handle, newValues[index]);\n          }\n        });\n      }\n    };\n    _this.handleRelease = function (newValues) {\n      var _a, _b;\n      var handleProps = getSortedInteractiveHandleProps(_this.props);\n      (_b = (_a = _this.props).onRelease) === null || _b === void 0 ? void 0 : _b.call(_a, newValues);\n      handleProps.forEach(function (handle, index) {\n        var _a;\n        (_a = handle.onRelease) === null || _a === void 0 ? void 0 : _a.call(handle, newValues[index]);\n      });\n    };\n    return _this;\n  }\n  MultiSlider.getDerivedStateFromProps = function (props) {\n    return {\n      labelPrecision: MultiSlider.getLabelPrecision(props)\n    };\n  };\n  MultiSlider.getLabelPrecision = function (_a) {\n    var labelPrecision = _a.labelPrecision,\n      stepSize = _a.stepSize;\n    // infer default label precision from stepSize because that's how much the handle moves.\n    return labelPrecision == null ? Utils.countDecimalPlaces(stepSize) : labelPrecision;\n  };\n  MultiSlider.prototype.getSnapshotBeforeUpdate = function (prevProps) {\n    var prevHandleProps = getSortedInteractiveHandleProps(prevProps);\n    var newHandleProps = getSortedInteractiveHandleProps(this.props);\n    if (newHandleProps.length !== prevHandleProps.length) {\n      // clear refs\n      this.handleElements = [];\n    }\n    return null;\n  };\n  MultiSlider.prototype.render = function () {\n    var _a;\n    var _this = this;\n    var classes = classNames(Classes.SLIDER, (_a = {}, _a[Classes.DISABLED] = this.props.disabled, _a[\"\".concat(Classes.SLIDER, \"-unlabeled\")] = this.props.labelRenderer === false, _a[Classes.VERTICAL] = this.props.vertical, _a), this.props.className);\n    return React.createElement(\"div\", {\n      className: classes,\n      onMouseDown: this.maybeHandleTrackClick,\n      onTouchStart: this.maybeHandleTrackTouch\n    }, React.createElement(\"div\", {\n      className: Classes.SLIDER_TRACK,\n      ref: function (ref) {\n        return _this.trackElement = ref;\n      }\n    }, this.renderTracks()), React.createElement(\"div\", {\n      className: Classes.SLIDER_AXIS\n    }, this.renderLabels()), this.renderHandles());\n  };\n  MultiSlider.prototype.componentDidMount = function () {\n    this.updateTickSize();\n  };\n  MultiSlider.prototype.componentDidUpdate = function (prevProps, prevState) {\n    _super.prototype.componentDidUpdate.call(this, prevProps, prevState);\n    this.updateTickSize();\n  };\n  MultiSlider.prototype.validateProps = function (props) {\n    if (props.stepSize <= 0) {\n      throw new Error(Errors.SLIDER_ZERO_STEP);\n    }\n    if (props.labelStepSize !== undefined && props.labelValues !== undefined) {\n      throw new Error(Errors.MULTISLIDER_WARN_LABEL_STEP_SIZE_LABEL_VALUES_MUTEX);\n    }\n    if (props.labelStepSize !== undefined && props.labelStepSize <= 0) {\n      throw new Error(Errors.SLIDER_ZERO_LABEL_STEP);\n    }\n    if (props.min !== undefined && !isFinite(props.min)) {\n      throw new Error(Errors.SLIDER_MIN);\n    }\n    if (props.max !== undefined && !isFinite(props.max)) {\n      throw new Error(Errors.SLIDER_MAX);\n    }\n    var anyInvalidChildren = false;\n    React.Children.forEach(props.children, function (child) {\n      // allow boolean coercion to omit nulls and false values\n      if (child && !Utils.isElementOfType(child, MultiSlider.Handle)) {\n        anyInvalidChildren = true;\n      }\n    });\n    if (anyInvalidChildren) {\n      throw new Error(Errors.MULTISLIDER_INVALID_CHILD);\n    }\n  };\n  MultiSlider.prototype.formatLabel = function (value, isHandleTooltip) {\n    if (isHandleTooltip === void 0) {\n      isHandleTooltip = false;\n    }\n    var labelRenderer = this.props.labelRenderer;\n    if (labelRenderer === false) {\n      return undefined;\n    } else if (Utils.isFunction(labelRenderer)) {\n      return labelRenderer(value, {\n        isHandleTooltip: isHandleTooltip\n      });\n    } else {\n      return value.toFixed(this.state.labelPrecision);\n    }\n  };\n  MultiSlider.prototype.renderLabels = function () {\n    var _this = this;\n    if (this.props.labelRenderer === false) {\n      return null;\n    }\n    var values = this.getLabelValues();\n    var _a = this.props,\n      max = _a.max,\n      min = _a.min;\n    var labels = values.map(function (step, i) {\n      var offsetPercentage = formatPercentage((step - min) / (max - min));\n      var style = _this.props.vertical ? {\n        bottom: offsetPercentage\n      } : {\n        left: offsetPercentage\n      };\n      return React.createElement(\"div\", {\n        className: Classes.SLIDER_LABEL,\n        key: i,\n        style: style\n      }, _this.formatLabel(step));\n    });\n    return labels;\n  };\n  MultiSlider.prototype.renderTracks = function () {\n    var trackStops = getSortedHandleProps(this.props);\n    trackStops.push({\n      value: this.props.max\n    });\n    // render from current to previous, then increment previous\n    var previous = {\n      value: this.props.min\n    };\n    var handles = [];\n    for (var index = 0; index < trackStops.length; index++) {\n      var current = trackStops[index];\n      handles.push(this.renderTrackFill(index, previous, current));\n      previous = current;\n    }\n    return handles;\n  };\n  MultiSlider.prototype.renderTrackFill = function (index, start, end) {\n    // ensure startRatio <= endRatio\n    var _a = [this.getOffsetRatio(start.value), this.getOffsetRatio(end.value)].sort(function (left, right) {\n        return left - right;\n      }),\n      startRatio = _a[0],\n      endRatio = _a[1];\n    var startOffset = formatPercentage(startRatio);\n    var endOffset = formatPercentage(1 - endRatio);\n    var orientationStyle = this.props.vertical ? {\n      bottom: startOffset,\n      top: endOffset,\n      left: 0\n    } : {\n      left: startOffset,\n      right: endOffset,\n      top: 0\n    };\n    var style = __assign(__assign({}, orientationStyle), start.trackStyleAfter || end.trackStyleBefore || {});\n    var classes = classNames(Classes.SLIDER_PROGRESS, Classes.intentClass(this.getTrackIntent(start, end)));\n    return React.createElement(\"div\", {\n      key: \"track-\".concat(index),\n      className: classes,\n      style: style\n    });\n  };\n  MultiSlider.prototype.renderHandles = function () {\n    var _this = this;\n    var _a = this.props,\n      disabled = _a.disabled,\n      max = _a.max,\n      min = _a.min,\n      stepSize = _a.stepSize,\n      vertical = _a.vertical;\n    var handleProps = getSortedInteractiveHandleProps(this.props);\n    if (handleProps.length === 0) {\n      return null;\n    }\n    return handleProps.map(function (_a, index) {\n      var _b;\n      var value = _a.value,\n        type = _a.type,\n        className = _a.className,\n        htmlProps = _a.htmlProps;\n      return React.createElement(Handle, {\n        htmlProps: htmlProps,\n        className: classNames((_b = {}, _b[Classes.START] = type === HandleType.START, _b[Classes.END] = type === HandleType.END, _b), className),\n        disabled: disabled,\n        key: \"\".concat(index, \"-\").concat(handleProps.length),\n        label: _this.formatLabel(value, true),\n        max: max,\n        min: min,\n        onChange: _this.getHandlerForIndex(index, _this.handleChange),\n        onRelease: _this.getHandlerForIndex(index, _this.handleRelease),\n        ref: _this.addHandleRef,\n        stepSize: stepSize,\n        tickSize: _this.state.tickSize,\n        tickSizeRatio: _this.state.tickSizeRatio,\n        value: value,\n        vertical: vertical\n      });\n    });\n  };\n  MultiSlider.prototype.nearestHandleForValue = function (handles, getOffset) {\n    return argMin(handles, function (handle) {\n      var offset = getOffset(handle);\n      var offsetValue = handle.clientToValue(offset);\n      var handleValue = handle.props.value;\n      return Math.abs(offsetValue - handleValue);\n    });\n  };\n  MultiSlider.prototype.getNewHandleValues = function (newValue, oldIndex) {\n    var handleProps = getSortedInteractiveHandleProps(this.props);\n    var oldValues = handleProps.map(function (handle) {\n      return handle.value;\n    });\n    var newValues = oldValues.slice();\n    newValues[oldIndex] = newValue;\n    newValues.sort(function (left, right) {\n      return left - right;\n    });\n    var newIndex = newValues.indexOf(newValue);\n    var lockIndex = this.findFirstLockedHandleIndex(oldIndex, newIndex);\n    if (lockIndex === -1) {\n      fillValues(newValues, oldIndex, newIndex, newValue);\n    } else {\n      // If pushing past a locked handle, discard the new value and only make the updates to clamp values against the lock.\n      var lockValue = oldValues[lockIndex];\n      fillValues(oldValues, oldIndex, lockIndex, lockValue);\n      return oldValues;\n    }\n    return newValues;\n  };\n  MultiSlider.prototype.findFirstLockedHandleIndex = function (startIndex, endIndex) {\n    var inc = startIndex < endIndex ? 1 : -1;\n    var handleProps = getSortedInteractiveHandleProps(this.props);\n    for (var index = startIndex + inc; index !== endIndex + inc; index += inc) {\n      if (handleProps[index].interactionKind !== HandleInteractionKind.PUSH) {\n        return index;\n      }\n    }\n    return -1;\n  };\n  MultiSlider.prototype.getLabelValues = function () {\n    var _a = this.props,\n      labelStepSize = _a.labelStepSize,\n      labelValues = _a.labelValues,\n      min = _a.min,\n      max = _a.max;\n    var values = [];\n    if (labelValues !== undefined) {\n      values = labelValues.slice();\n    } else {\n      for (var i = min; i < max || Utils.approxEqual(i, max); i += labelStepSize !== null && labelStepSize !== void 0 ? labelStepSize : 1) {\n        values.push(i);\n      }\n    }\n    return values;\n  };\n  MultiSlider.prototype.getOffsetRatio = function (value) {\n    return Utils.clamp((value - this.props.min) * this.state.tickSizeRatio, 0, 1);\n  };\n  MultiSlider.prototype.getTrackIntent = function (start, end) {\n    if (!this.props.showTrackFill) {\n      return Intent.NONE;\n    }\n    if (start.intentAfter !== undefined) {\n      return start.intentAfter;\n    } else if (end !== undefined && end.intentBefore !== undefined) {\n      return end.intentBefore;\n    }\n    return this.props.defaultTrackIntent;\n  };\n  MultiSlider.prototype.updateTickSize = function () {\n    if (this.trackElement != null) {\n      var trackSize = this.props.vertical ? this.trackElement.clientHeight : this.trackElement.clientWidth;\n      var tickSizeRatio = 1 / (this.props.max - this.props.min);\n      var tickSize = trackSize * tickSizeRatio;\n      this.setState({\n        tickSize: tickSize,\n        tickSizeRatio: tickSizeRatio\n      });\n    }\n  };\n  MultiSlider.defaultSliderProps = {\n    disabled: false,\n    max: 10,\n    min: 0,\n    showTrackFill: true,\n    stepSize: 1,\n    vertical: false\n  };\n  MultiSlider.defaultProps = __assign(__assign({}, MultiSlider.defaultSliderProps), {\n    defaultTrackIntent: Intent.NONE\n  });\n  MultiSlider.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".MultiSlider\");\n  MultiSlider.Handle = MultiSliderHandle;\n  return MultiSlider;\n}(AbstractPureComponent);\nexport { MultiSlider };\nfunction getLabelPrecision(_a) {\n  var labelPrecision = _a.labelPrecision,\n    _b = _a.stepSize,\n    stepSize = _b === void 0 ? MultiSlider.defaultSliderProps.stepSize : _b;\n  // infer default label precision from stepSize because that's how much the handle moves.\n  return labelPrecision == null ? Utils.countDecimalPlaces(stepSize) : labelPrecision;\n}\nfunction getSortedInteractiveHandleProps(props) {\n  return getSortedHandleProps(props, function (childProps) {\n    return childProps.interactionKind !== HandleInteractionKind.NONE;\n  });\n}\nfunction getSortedHandleProps(_a, predicate) {\n  var children = _a.children;\n  if (predicate === void 0) {\n    predicate = function () {\n      return true;\n    };\n  }\n  var maybeHandles = React.Children.map(children, function (child) {\n    return Utils.isElementOfType(child, MultiSlider.Handle) && predicate(child.props) ? child.props : null;\n  });\n  var handles = maybeHandles != null ? maybeHandles : [];\n  handles = handles.filter(function (handle) {\n    return handle !== null;\n  });\n  handles.sort(function (left, right) {\n    return left.value - right.value;\n  });\n  return handles;\n}","map":{"version":3,"names":["classNames","React","AbstractPureComponent","Classes","DISPLAYNAME_PREFIX","Intent","Utils","Errors","Handle","HandleInteractionKind","HandleType","argMin","fillValues","formatPercentage","MultiSliderHandle","displayName","concat","MultiSlider","_super","__extends","_this","apply","arguments","state","labelPrecision","getLabelPrecision","props","tickSize","tickSizeRatio","handleElements","trackElement","addHandleRef","ref","push","maybeHandleTrackClick","event","canHandleTrackEvent","foundHandle","nearestHandleForValue","handle","mouseEventClientOffset","beginHandleMovement","maybeHandleTrackTouch","touchEventClientOffset","beginHandleTouchMovement","target","disabled","closest","SLIDER_HANDLE","getHandlerForIndex","index","callback","newValue","getNewHandleValues","handleChange","newValues","handleProps","getSortedInteractiveHandleProps","oldValues","map","value","arraysEqual","_b","_a","onChange","call","forEach","handleRelease","onRelease","getDerivedStateFromProps","stepSize","countDecimalPlaces","prototype","getSnapshotBeforeUpdate","prevProps","prevHandleProps","newHandleProps","length","render","classes","SLIDER","DISABLED","labelRenderer","VERTICAL","vertical","className","createElement","onMouseDown","onTouchStart","SLIDER_TRACK","renderTracks","SLIDER_AXIS","renderLabels","renderHandles","componentDidMount","updateTickSize","componentDidUpdate","prevState","validateProps","Error","SLIDER_ZERO_STEP","labelStepSize","undefined","labelValues","MULTISLIDER_WARN_LABEL_STEP_SIZE_LABEL_VALUES_MUTEX","SLIDER_ZERO_LABEL_STEP","min","isFinite","SLIDER_MIN","max","SLIDER_MAX","anyInvalidChildren","Children","children","child","isElementOfType","MULTISLIDER_INVALID_CHILD","formatLabel","isHandleTooltip","isFunction","toFixed","values","getLabelValues","labels","step","i","offsetPercentage","style","bottom","left","SLIDER_LABEL","key","trackStops","getSortedHandleProps","previous","handles","current","renderTrackFill","start","end","getOffsetRatio","sort","right","startRatio","endRatio","startOffset","endOffset","orientationStyle","top","__assign","trackStyleAfter","trackStyleBefore","SLIDER_PROGRESS","intentClass","getTrackIntent","type","htmlProps","START","END","label","getOffset","offset","offsetValue","clientToValue","handleValue","Math","abs","oldIndex","slice","newIndex","indexOf","lockIndex","findFirstLockedHandleIndex","lockValue","startIndex","endIndex","inc","interactionKind","PUSH","approxEqual","clamp","showTrackFill","NONE","intentAfter","intentBefore","defaultTrackIntent","trackSize","clientHeight","clientWidth","setState","defaultSliderProps","defaultProps","childProps","predicate","maybeHandles","filter"],"sources":["/home/meander/Desktop/Akash/Workit/my-app/node_modules/@blueprintjs/core/src/components/slider/multiSlider.tsx"],"sourcesContent":["/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport { AbstractPureComponent, Classes, DISPLAYNAME_PREFIX, Intent, IntentProps, Props, Utils } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { Handle } from \"./handle\";\nimport { HandleInteractionKind, HandleProps, HandleType } from \"./handleProps\";\nimport { argMin, fillValues, formatPercentage } from \"./sliderUtils\";\n\n/**\n * SFC used to pass slider handle props to a `MultiSlider`.\n * This element is not rendered directly.\n */\nconst MultiSliderHandle: React.FC<HandleProps> = () => null;\nMultiSliderHandle.displayName = `${DISPLAYNAME_PREFIX}.MultiSliderHandle`;\n\nexport interface SliderBaseProps extends Props, IntentProps {\n    children?: React.ReactNode;\n\n    /**\n     * Whether the slider is non-interactive.\n     *\n     * @default false\n     */\n    disabled?: boolean;\n\n    /**\n     * Increment between successive labels. Must be greater than zero.\n     *\n     * @default inferred (if labelStepSize is undefined)\n     */\n    labelStepSize?: number;\n\n    /**\n     * Array of specific values for the label placement. This prop is mutually exclusive with\n     * `labelStepSize`.\n     */\n    labelValues?: readonly number[];\n\n    /**\n     * Number of decimal places to use when rendering label value. Default value is the number of\n     * decimals used in the `stepSize` prop. This prop has _no effect_ if you supply a custom\n     * `labelRenderer` callback.\n     *\n     * @default inferred from stepSize\n     */\n    labelPrecision?: number;\n\n    /**\n     * Maximum value of the slider. Value must be a finite number.\n     *\n     * @default 10\n     */\n    max?: number;\n\n    /**\n     * Minimum value of the slider. Value must be a finite number.\n     *\n     * @default 0\n     */\n    min?: number;\n\n    /**\n     * Whether a solid bar should be rendered on the track between current and initial values,\n     * or between handles for `RangeSlider`.\n     *\n     * @default true\n     */\n    showTrackFill?: boolean;\n\n    /**\n     * Increment between successive values; amount by which the handle moves. Must be greater than zero.\n     *\n     * @default 1\n     */\n    stepSize?: number;\n\n    /**\n     * Callback to render a single label. Useful for formatting numbers as currency or percentages.\n     * If `true`, labels will use number value formatted to `labelPrecision` decimal places.\n     * If `false`, labels will not be shown.\n     *\n     * The callback is provided a numeric value and optional rendering options, which include:\n     * - isHandleTooltip: whether this label is being rendered within a handle tooltip\n     *\n     * @default true\n     */\n    labelRenderer?: boolean | ((value: number, opts?: { isHandleTooltip: boolean }) => string | JSX.Element);\n\n    /**\n     * Whether to show the slider in a vertical orientation.\n     *\n     * @default false\n     */\n    vertical?: boolean;\n}\n\nexport interface MultiSliderProps extends SliderBaseProps {\n    /** Default intent of a track segment, used only if no handle specifies `intentBefore/After`. */\n    defaultTrackIntent?: Intent;\n\n    /** Callback invoked when a handle value changes. Receives handle values in sorted order. */\n    onChange?(values: number[]): void;\n\n    /** Callback invoked when a handle is released. Receives handle values in sorted order. */\n    onRelease?(values: number[]): void;\n}\n\nexport interface SliderState {\n    labelPrecision: number;\n    /** the client size, in pixels, of one tick */\n    tickSize: number;\n    /** the size of one tick as a ratio of the component's client size */\n    tickSizeRatio: number;\n}\n\n/**\n * Multi slider component.\n *\n * @see https://blueprintjs.com/docs/#core/components/sliders.multi-slider\n */\nexport class MultiSlider extends AbstractPureComponent<MultiSliderProps, SliderState> {\n    public static defaultSliderProps: SliderBaseProps = {\n        disabled: false,\n        max: 10,\n        min: 0,\n        showTrackFill: true,\n        stepSize: 1,\n        vertical: false,\n    };\n\n    public static defaultProps: MultiSliderProps = {\n        ...MultiSlider.defaultSliderProps,\n        defaultTrackIntent: Intent.NONE,\n    };\n\n    public static displayName = `${DISPLAYNAME_PREFIX}.MultiSlider`;\n\n    public static Handle = MultiSliderHandle;\n\n    public static getDerivedStateFromProps(props: MultiSliderProps) {\n        return { labelPrecision: MultiSlider.getLabelPrecision(props) };\n    }\n\n    private static getLabelPrecision({ labelPrecision, stepSize }: MultiSliderProps) {\n        // infer default label precision from stepSize because that's how much the handle moves.\n        return labelPrecision == null ? Utils.countDecimalPlaces(stepSize!) : labelPrecision;\n    }\n\n    public state: SliderState = {\n        labelPrecision: getLabelPrecision(this.props),\n        tickSize: 0,\n        tickSizeRatio: 0,\n    };\n\n    private handleElements: Handle[] = [];\n\n    private trackElement: HTMLElement | null = null;\n\n    public getSnapshotBeforeUpdate(prevProps: MultiSliderProps): null {\n        const prevHandleProps = getSortedInteractiveHandleProps(prevProps);\n        const newHandleProps = getSortedInteractiveHandleProps(this.props);\n        if (newHandleProps.length !== prevHandleProps.length) {\n            // clear refs\n            this.handleElements = [];\n        }\n        return null;\n    }\n\n    public render() {\n        const classes = classNames(\n            Classes.SLIDER,\n            {\n                [Classes.DISABLED]: this.props.disabled,\n                [`${Classes.SLIDER}-unlabeled`]: this.props.labelRenderer === false,\n                [Classes.VERTICAL]: this.props.vertical,\n            },\n            this.props.className,\n        );\n        return (\n            <div className={classes} onMouseDown={this.maybeHandleTrackClick} onTouchStart={this.maybeHandleTrackTouch}>\n                <div className={Classes.SLIDER_TRACK} ref={ref => (this.trackElement = ref)}>\n                    {this.renderTracks()}\n                </div>\n                <div className={Classes.SLIDER_AXIS}>{this.renderLabels()}</div>\n                {this.renderHandles()}\n            </div>\n        );\n    }\n\n    public componentDidMount() {\n        this.updateTickSize();\n    }\n\n    public componentDidUpdate(prevProps: MultiSliderProps, prevState: SliderState) {\n        super.componentDidUpdate(prevProps, prevState);\n        this.updateTickSize();\n    }\n\n    protected validateProps(props: React.PropsWithChildren<MultiSliderProps>) {\n        if (props.stepSize! <= 0) {\n            throw new Error(Errors.SLIDER_ZERO_STEP);\n        }\n        if (props.labelStepSize !== undefined && props.labelValues !== undefined) {\n            throw new Error(Errors.MULTISLIDER_WARN_LABEL_STEP_SIZE_LABEL_VALUES_MUTEX);\n        }\n        if (props.labelStepSize !== undefined && props.labelStepSize! <= 0) {\n            throw new Error(Errors.SLIDER_ZERO_LABEL_STEP);\n        }\n        if (props.min !== undefined && !isFinite(props.min)) {\n            throw new Error(Errors.SLIDER_MIN);\n        }\n        if (props.max !== undefined && !isFinite(props.max)) {\n            throw new Error(Errors.SLIDER_MAX);\n        }\n\n        let anyInvalidChildren = false;\n        React.Children.forEach(props.children, child => {\n            // allow boolean coercion to omit nulls and false values\n            if (child && !Utils.isElementOfType(child, MultiSlider.Handle)) {\n                anyInvalidChildren = true;\n            }\n        });\n        if (anyInvalidChildren) {\n            throw new Error(Errors.MULTISLIDER_INVALID_CHILD);\n        }\n    }\n\n    private formatLabel(value: number, isHandleTooltip: boolean = false) {\n        const { labelRenderer } = this.props;\n        if (labelRenderer === false) {\n            return undefined;\n        } else if (Utils.isFunction(labelRenderer)) {\n            return labelRenderer(value, { isHandleTooltip });\n        } else {\n            return value.toFixed(this.state.labelPrecision);\n        }\n    }\n\n    private renderLabels() {\n        if (this.props.labelRenderer === false) {\n            return null;\n        }\n\n        const values = this.getLabelValues();\n        const { max, min } = this.props;\n        const labels = values.map((step, i) => {\n            const offsetPercentage = formatPercentage((step - min!) / (max! - min!));\n            const style = this.props.vertical ? { bottom: offsetPercentage } : { left: offsetPercentage };\n            return (\n                <div className={Classes.SLIDER_LABEL} key={i} style={style}>\n                    {this.formatLabel(step)}\n                </div>\n            );\n        });\n\n        return labels;\n    }\n\n    private renderTracks() {\n        const trackStops = getSortedHandleProps(this.props);\n        trackStops.push({ value: this.props.max! });\n\n        // render from current to previous, then increment previous\n        let previous: HandleProps = { value: this.props.min! };\n        const handles: JSX.Element[] = [];\n        for (let index = 0; index < trackStops.length; index++) {\n            const current = trackStops[index];\n            handles.push(this.renderTrackFill(index, previous, current));\n            previous = current;\n        }\n        return handles;\n    }\n\n    private renderTrackFill(index: number, start: HandleProps, end: HandleProps) {\n        // ensure startRatio <= endRatio\n        const [startRatio, endRatio] = [this.getOffsetRatio(start.value), this.getOffsetRatio(end.value)].sort(\n            (left, right) => left - right,\n        );\n        const startOffset = formatPercentage(startRatio);\n        const endOffset = formatPercentage(1 - endRatio);\n        const orientationStyle: React.CSSProperties = this.props.vertical\n            ? { bottom: startOffset, top: endOffset, left: 0 }\n            : { left: startOffset, right: endOffset, top: 0 };\n\n        const style: React.CSSProperties = {\n            ...orientationStyle,\n            ...(start.trackStyleAfter || end.trackStyleBefore || {}),\n        };\n\n        const classes = classNames(Classes.SLIDER_PROGRESS, Classes.intentClass(this.getTrackIntent(start, end)));\n        return <div key={`track-${index}`} className={classes} style={style} />;\n    }\n\n    private renderHandles() {\n        const { disabled, max, min, stepSize, vertical } = this.props;\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n\n        if (handleProps.length === 0) {\n            return null;\n        }\n\n        return handleProps.map(({ value, type, className, htmlProps }, index) => (\n            <Handle\n                htmlProps={htmlProps}\n                className={classNames(\n                    {\n                        [Classes.START]: type === HandleType.START,\n                        [Classes.END]: type === HandleType.END,\n                    },\n                    className,\n                )}\n                disabled={disabled}\n                key={`${index}-${handleProps.length}`}\n                label={this.formatLabel(value, true)}\n                max={max!}\n                min={min!}\n                onChange={this.getHandlerForIndex(index, this.handleChange)}\n                onRelease={this.getHandlerForIndex(index, this.handleRelease)}\n                ref={this.addHandleRef}\n                stepSize={stepSize!}\n                tickSize={this.state.tickSize}\n                tickSizeRatio={this.state.tickSizeRatio}\n                value={value}\n                vertical={vertical!}\n            />\n        ));\n    }\n\n    private addHandleRef = (ref: Handle) => {\n        if (ref != null) {\n            this.handleElements.push(ref);\n        }\n    };\n\n    private maybeHandleTrackClick = (event: React.MouseEvent<HTMLDivElement>) => {\n        if (this.canHandleTrackEvent(event)) {\n            const foundHandle = this.nearestHandleForValue(this.handleElements, handle =>\n                handle.mouseEventClientOffset(event),\n            );\n            if (foundHandle) {\n                foundHandle.beginHandleMovement(event);\n            }\n        }\n    };\n\n    private maybeHandleTrackTouch = (event: React.TouchEvent<HTMLDivElement>) => {\n        if (this.canHandleTrackEvent(event)) {\n            const foundHandle = this.nearestHandleForValue(this.handleElements, handle =>\n                handle.touchEventClientOffset(event),\n            );\n            if (foundHandle) {\n                foundHandle.beginHandleTouchMovement(event);\n            }\n        }\n    };\n\n    private canHandleTrackEvent = (event: React.MouseEvent<HTMLDivElement> | React.TouchEvent<HTMLDivElement>) => {\n        const target = event.target as HTMLElement;\n        // ensure event does not come from inside the handle\n        return !this.props.disabled && target.closest(`.${Classes.SLIDER_HANDLE}`) == null;\n    };\n\n    private nearestHandleForValue(handles: Handle[], getOffset: (handle: Handle) => number): Handle | undefined {\n        return argMin(handles, handle => {\n            const offset = getOffset(handle);\n            const offsetValue = handle.clientToValue(offset);\n            const handleValue = handle.props.value!;\n            return Math.abs(offsetValue - handleValue);\n        });\n    }\n\n    private getHandlerForIndex = (index: number, callback?: (values: number[]) => void) => {\n        return (newValue: number) => {\n            callback?.(this.getNewHandleValues(newValue, index));\n        };\n    };\n\n    private getNewHandleValues(newValue: number, oldIndex: number) {\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n        const oldValues = handleProps.map(handle => handle.value);\n        const newValues = oldValues.slice();\n        newValues[oldIndex] = newValue;\n        newValues.sort((left, right) => left - right);\n\n        const newIndex = newValues.indexOf(newValue);\n        const lockIndex = this.findFirstLockedHandleIndex(oldIndex, newIndex);\n        if (lockIndex === -1) {\n            fillValues(newValues, oldIndex, newIndex, newValue);\n        } else {\n            // If pushing past a locked handle, discard the new value and only make the updates to clamp values against the lock.\n            const lockValue = oldValues[lockIndex];\n            fillValues(oldValues, oldIndex, lockIndex, lockValue);\n            return oldValues;\n        }\n\n        return newValues;\n    }\n\n    private findFirstLockedHandleIndex(startIndex: number, endIndex: number): number {\n        const inc = startIndex < endIndex ? 1 : -1;\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n\n        for (let index = startIndex + inc; index !== endIndex + inc; index += inc) {\n            if (handleProps[index].interactionKind !== HandleInteractionKind.PUSH) {\n                return index;\n            }\n        }\n\n        return -1;\n    }\n\n    private handleChange = (newValues: number[]) => {\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n        const oldValues = handleProps.map(handle => handle.value);\n        if (!Utils.arraysEqual(newValues, oldValues)) {\n            this.props.onChange?.(newValues);\n            handleProps.forEach((handle, index) => {\n                if (oldValues[index] !== newValues[index]) {\n                    handle.onChange?.(newValues[index]);\n                }\n            });\n        }\n    };\n\n    private handleRelease = (newValues: number[]) => {\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n        this.props.onRelease?.(newValues);\n        handleProps.forEach((handle, index) => {\n            handle.onRelease?.(newValues[index]);\n        });\n    };\n\n    private getLabelValues() {\n        const { labelStepSize, labelValues, min, max } = this.props;\n        let values: number[] = [];\n        if (labelValues !== undefined) {\n            values = labelValues.slice();\n        } else {\n            for (let i = min!; i < max! || Utils.approxEqual(i, max!); i += labelStepSize ?? 1) {\n                values.push(i);\n            }\n        }\n\n        return values;\n    }\n\n    private getOffsetRatio(value: number) {\n        return Utils.clamp((value - this.props.min!) * this.state.tickSizeRatio, 0, 1);\n    }\n\n    private getTrackIntent(start: HandleProps, end?: HandleProps): Intent {\n        if (!this.props.showTrackFill) {\n            return Intent.NONE;\n        }\n        if (start.intentAfter !== undefined) {\n            return start.intentAfter;\n        } else if (end !== undefined && end.intentBefore !== undefined) {\n            return end.intentBefore;\n        }\n        return this.props.defaultTrackIntent!;\n    }\n\n    private updateTickSize() {\n        if (this.trackElement != null) {\n            const trackSize = this.props.vertical ? this.trackElement.clientHeight : this.trackElement.clientWidth;\n            const tickSizeRatio = 1 / ((this.props.max as number) - (this.props.min as number));\n            const tickSize = trackSize * tickSizeRatio;\n            this.setState({ tickSize, tickSizeRatio });\n        }\n    }\n}\n\nfunction getLabelPrecision({ labelPrecision, stepSize = MultiSlider.defaultSliderProps.stepSize! }: MultiSliderProps) {\n    // infer default label precision from stepSize because that's how much the handle moves.\n    return labelPrecision == null ? Utils.countDecimalPlaces(stepSize) : labelPrecision;\n}\n\nfunction getSortedInteractiveHandleProps(props: React.PropsWithChildren<MultiSliderProps>): HandleProps[] {\n    return getSortedHandleProps(props, childProps => childProps.interactionKind !== HandleInteractionKind.NONE);\n}\n\nfunction getSortedHandleProps({ children }: MultiSliderProps, predicate: (props: HandleProps) => boolean = () => true) {\n    const maybeHandles = React.Children.map(children, child =>\n        Utils.isElementOfType(child, MultiSlider.Handle) && predicate(child.props) ? child.props : null,\n    );\n    let handles = maybeHandles != null ? maybeHandles : [];\n    handles = handles.filter(handle => handle !== null);\n    handles.sort((left, right) => left.value - right.value);\n    return handles;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}