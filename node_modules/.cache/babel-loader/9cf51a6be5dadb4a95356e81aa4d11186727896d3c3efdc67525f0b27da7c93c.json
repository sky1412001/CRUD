{"ast":null,"code":"/*\n * Copyright 2015 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { CSSTransition, TransitionGroup } from \"react-transition-group\";\nimport { AbstractPureComponent, Classes } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { getActiveElement, isFunction } from \"../../common/utils\";\nimport { Portal } from \"../portal/portal\";\n/**\n * Overlay component.\n *\n * @see https://blueprintjs.com/docs/#core/components/overlay\n */\nvar Overlay = /** @class */function (_super) {\n  __extends(Overlay, _super);\n  function Overlay() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.isAutoFocusing = false;\n    _this.state = {\n      hasEverOpened: _this.props.isOpen\n    };\n    /** Ref for container element, containing all children and the backdrop */\n    _this.containerElement = React.createRef();\n    // An empty, keyboard-focusable div at the beginning of the Overlay content\n    _this.startFocusTrapElement = React.createRef();\n    // An empty, keyboard-focusable div at the end of the Overlay content\n    _this.endFocusTrapElement = React.createRef();\n    _this.maybeRenderChild = function (child) {\n      if (isFunction(child)) {\n        child = child();\n      }\n      if (child == null) {\n        return null;\n      }\n      // decorate the child with a few injected props\n      var tabIndex = _this.props.enforceFocus || _this.props.autoFocus ? 0 : undefined;\n      var decoratedChild = typeof child === \"object\" ? React.cloneElement(child, {\n        className: classNames(child.props.className, Classes.OVERLAY_CONTENT),\n        tabIndex: tabIndex\n      }) : React.createElement(\"span\", {\n        className: Classes.OVERLAY_CONTENT,\n        tabIndex: tabIndex\n      }, child);\n      var _a = _this.props,\n        onOpening = _a.onOpening,\n        onOpened = _a.onOpened,\n        onClosing = _a.onClosing,\n        transitionDuration = _a.transitionDuration,\n        transitionName = _a.transitionName;\n      return React.createElement(CSSTransition, {\n        classNames: transitionName,\n        onEntering: onOpening,\n        onEntered: onOpened,\n        onExiting: onClosing,\n        onExited: _this.handleTransitionExited,\n        timeout: transitionDuration,\n        addEndListener: _this.handleTransitionAddEnd\n      }, decoratedChild);\n    };\n    /**\n     * Ensures repeatedly pressing shift+tab keeps focus inside the Overlay. Moves focus to\n     * the `endFocusTrapElement` or the first keyboard-focusable element in the Overlay (excluding\n     * the `startFocusTrapElement`), depending on whether the element losing focus is inside the\n     * Overlay.\n     */\n    _this.handleStartFocusTrapElementFocus = function (e) {\n      var _a, _b;\n      if (!_this.props.enforceFocus || _this.isAutoFocusing) {\n        return;\n      }\n      // e.relatedTarget will not be defined if this was a programmatic focus event, as is the\n      // case when we call this.bringFocusInsideOverlay() after a user clicked on the backdrop.\n      // Otherwise, we're handling a user interaction, and we should wrap around to the last\n      // element in this transition group.\n      if (e.relatedTarget != null && ((_a = _this.containerElement.current) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget)) && e.relatedTarget !== _this.endFocusTrapElement.current) {\n        (_b = _this.endFocusTrapElement.current) === null || _b === void 0 ? void 0 : _b.focus({\n          preventScroll: true\n        });\n      }\n    };\n    /**\n     * Wrap around to the end of the dialog if `enforceFocus` is enabled.\n     */\n    _this.handleStartFocusTrapElementKeyDown = function (e) {\n      var _a;\n      if (!_this.props.enforceFocus) {\n        return;\n      }\n      if (e.shiftKey && e.key === \"Tab\") {\n        var lastFocusableElement = _this.getKeyboardFocusableElements().pop();\n        if (lastFocusableElement != null) {\n          lastFocusableElement.focus();\n        } else {\n          (_a = _this.endFocusTrapElement.current) === null || _a === void 0 ? void 0 : _a.focus({\n            preventScroll: true\n          });\n        }\n      }\n    };\n    /**\n     * Ensures repeatedly pressing tab keeps focus inside the Overlay. Moves focus to the\n     * `startFocusTrapElement` or the last keyboard-focusable element in the Overlay (excluding the\n     * `startFocusTrapElement`), depending on whether the element losing focus is inside the\n     * Overlay.\n     */\n    _this.handleEndFocusTrapElementFocus = function (e) {\n      var _a, _b, _c;\n      // No need for this.props.enforceFocus check here because this element is only rendered\n      // when that prop is true.\n      // During user interactions, e.relatedTarget will be defined, and we should wrap around to the\n      // \"start focus trap\" element.\n      // Otherwise, we're handling a programmatic focus event, which can only happen after a user\n      // presses shift+tab from the first focusable element in the overlay.\n      if (e.relatedTarget != null && ((_a = _this.containerElement.current) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget)) && e.relatedTarget !== _this.startFocusTrapElement.current) {\n        var firstFocusableElement = _this.getKeyboardFocusableElements().shift();\n        // ensure we don't re-focus an already active element by comparing against e.relatedTarget\n        if (!_this.isAutoFocusing && firstFocusableElement != null && firstFocusableElement !== e.relatedTarget) {\n          firstFocusableElement.focus();\n        } else {\n          (_b = _this.startFocusTrapElement.current) === null || _b === void 0 ? void 0 : _b.focus({\n            preventScroll: true\n          });\n        }\n      } else {\n        var lastFocusableElement = _this.getKeyboardFocusableElements().pop();\n        if (lastFocusableElement != null) {\n          lastFocusableElement.focus();\n        } else {\n          // Keeps focus within Overlay even if there are no keyboard-focusable children\n          (_c = _this.startFocusTrapElement.current) === null || _c === void 0 ? void 0 : _c.focus({\n            preventScroll: true\n          });\n        }\n      }\n    };\n    _this.handleTransitionExited = function (node) {\n      var _a, _b;\n      if (_this.props.shouldReturnFocusOnClose && _this.lastActiveElementBeforeOpened instanceof HTMLElement) {\n        _this.lastActiveElementBeforeOpened.focus();\n      }\n      (_b = (_a = _this.props).onClosed) === null || _b === void 0 ? void 0 : _b.call(_a, node);\n    };\n    _this.handleBackdropMouseDown = function (e) {\n      var _a;\n      var _b = _this.props,\n        backdropProps = _b.backdropProps,\n        canOutsideClickClose = _b.canOutsideClickClose,\n        enforceFocus = _b.enforceFocus,\n        onClose = _b.onClose;\n      if (canOutsideClickClose) {\n        onClose === null || onClose === void 0 ? void 0 : onClose(e);\n      }\n      if (enforceFocus) {\n        _this.bringFocusInsideOverlay();\n      }\n      (_a = backdropProps === null || backdropProps === void 0 ? void 0 : backdropProps.onMouseDown) === null || _a === void 0 ? void 0 : _a.call(backdropProps, e);\n    };\n    _this.handleDocumentClick = function (e) {\n      var _a = _this.props,\n        canOutsideClickClose = _a.canOutsideClickClose,\n        isOpen = _a.isOpen,\n        onClose = _a.onClose;\n      // get the actual target even in the Shadow DOM\n      // see https://github.com/palantir/blueprint/issues/4220\n      var eventTarget = e.composed ? e.composedPath()[0] : e.target;\n      var stackIndex = Overlay.openStack.indexOf(_this);\n      var isClickInThisOverlayOrDescendant = Overlay.openStack.slice(stackIndex).some(function (_a) {\n        var _b;\n        var elem = _a.containerElement;\n        // `elem` is the container of backdrop & content, so clicking directly on that container\n        // should not count as being \"inside\" the overlay.\n        return ((_b = elem.current) === null || _b === void 0 ? void 0 : _b.contains(eventTarget)) && !elem.current.isSameNode(eventTarget);\n      });\n      if (isOpen && !isClickInThisOverlayOrDescendant && canOutsideClickClose) {\n        // casting to any because this is a native event\n        onClose === null || onClose === void 0 ? void 0 : onClose(e);\n      }\n    };\n    /**\n     * When multiple Overlays are open, this event handler is only active for the most recently\n     * opened one to avoid Overlays competing with each other for focus.\n     */\n    _this.handleDocumentFocus = function (e) {\n      // get the actual target even in the Shadow DOM\n      // see https://github.com/palantir/blueprint/issues/4220\n      var eventTarget = e.composed ? e.composedPath()[0] : e.target;\n      if (_this.props.enforceFocus && _this.containerElement.current != null && eventTarget instanceof Node && !_this.containerElement.current.contains(eventTarget)) {\n        // prevent default focus behavior (sometimes auto-scrolls the page)\n        e.preventDefault();\n        e.stopImmediatePropagation();\n        _this.bringFocusInsideOverlay();\n      }\n    };\n    _this.handleKeyDown = function (e) {\n      var _a = _this.props,\n        canEscapeKeyClose = _a.canEscapeKeyClose,\n        onClose = _a.onClose;\n      if (e.key === \"Escape\" && canEscapeKeyClose) {\n        onClose === null || onClose === void 0 ? void 0 : onClose(e);\n        // prevent other overlays from closing\n        e.stopPropagation();\n        // prevent browser-specific escape key behavior (Safari exits fullscreen)\n        e.preventDefault();\n      }\n    };\n    _this.handleTransitionAddEnd = function () {\n      // no-op\n    };\n    return _this;\n  }\n  Overlay.getDerivedStateFromProps = function (_a) {\n    var hasEverOpened = _a.isOpen;\n    if (hasEverOpened) {\n      return {\n        hasEverOpened: hasEverOpened\n      };\n    }\n    return null;\n  };\n  Overlay.prototype.render = function () {\n    var _a;\n    var _b;\n    // oh snap! no reason to render anything at all if we're being truly lazy\n    if (this.props.lazy && !this.state.hasEverOpened) {\n      return null;\n    }\n    var _c = this.props,\n      autoFocus = _c.autoFocus,\n      children = _c.children,\n      className = _c.className,\n      enforceFocus = _c.enforceFocus,\n      usePortal = _c.usePortal,\n      isOpen = _c.isOpen;\n    // TransitionGroup types require single array of children; does not support nested arrays.\n    // So we must collapse backdrop and children into one array, and every item must be wrapped in a\n    // Transition element (no ReactText allowed).\n    var childrenWithTransitions = isOpen ? (_b = React.Children.map(children, this.maybeRenderChild)) !== null && _b !== void 0 ? _b : [] : [];\n    var maybeBackdrop = this.maybeRenderBackdrop();\n    if (maybeBackdrop !== null) {\n      childrenWithTransitions.unshift(maybeBackdrop);\n    }\n    if (isOpen && (autoFocus || enforceFocus) && childrenWithTransitions.length > 0) {\n      childrenWithTransitions.unshift(this.renderDummyElement(\"__start\", {\n        className: Classes.OVERLAY_START_FOCUS_TRAP,\n        onFocus: this.handleStartFocusTrapElementFocus,\n        onKeyDown: this.handleStartFocusTrapElementKeyDown,\n        ref: this.startFocusTrapElement\n      }));\n      if (enforceFocus) {\n        childrenWithTransitions.push(this.renderDummyElement(\"__end\", {\n          className: Classes.OVERLAY_END_FOCUS_TRAP,\n          onFocus: this.handleEndFocusTrapElementFocus,\n          ref: this.endFocusTrapElement\n        }));\n      }\n    }\n    var containerClasses = classNames(Classes.OVERLAY, (_a = {}, _a[Classes.OVERLAY_OPEN] = isOpen, _a[Classes.OVERLAY_INLINE] = !usePortal, _a), className);\n    var transitionGroup = React.createElement(\"div\", {\n      \"aria-live\": \"polite\",\n      className: containerClasses,\n      onKeyDown: this.handleKeyDown,\n      ref: this.containerElement\n    }, React.createElement(TransitionGroup, {\n      appear: true,\n      component: null\n    }, childrenWithTransitions));\n    if (usePortal) {\n      return React.createElement(Portal, {\n        className: this.props.portalClassName,\n        container: this.props.portalContainer,\n        stopPropagationEvents: this.props.portalStopPropagationEvents\n      }, transitionGroup);\n    } else {\n      return transitionGroup;\n    }\n  };\n  Overlay.prototype.componentDidMount = function () {\n    if (this.props.isOpen) {\n      this.overlayWillOpen();\n    }\n  };\n  Overlay.prototype.componentDidUpdate = function (prevProps) {\n    if (prevProps.isOpen && !this.props.isOpen) {\n      this.overlayWillClose();\n    } else if (!prevProps.isOpen && this.props.isOpen) {\n      this.overlayWillOpen();\n    }\n  };\n  Overlay.prototype.componentWillUnmount = function () {\n    this.overlayWillClose();\n  };\n  /**\n   * @public for testing\n   * @internal\n   */\n  Overlay.prototype.bringFocusInsideOverlay = function () {\n    var _this = this;\n    // always delay focus manipulation to just before repaint to prevent scroll jumping\n    return this.requestAnimationFrame(function () {\n      var _a;\n      // container element may be undefined between component mounting and Portal rendering\n      // activeElement may be undefined in some rare cases in IE\n      var activeElement = getActiveElement(_this.containerElement.current);\n      if (_this.containerElement.current == null || activeElement == null || !_this.props.isOpen) {\n        return;\n      }\n      var container = _this.containerElement.current;\n      var isFocusOutsideModal = !container.contains(activeElement);\n      if (isFocusOutsideModal) {\n        (_a = _this.startFocusTrapElement.current) === null || _a === void 0 ? void 0 : _a.focus({\n          preventScroll: true\n        });\n        _this.isAutoFocusing = false;\n      }\n    });\n  };\n  Overlay.prototype.maybeRenderBackdrop = function () {\n    var _a = this.props,\n      backdropClassName = _a.backdropClassName,\n      backdropProps = _a.backdropProps,\n      hasBackdrop = _a.hasBackdrop,\n      isOpen = _a.isOpen,\n      transitionDuration = _a.transitionDuration,\n      transitionName = _a.transitionName;\n    if (hasBackdrop && isOpen) {\n      return React.createElement(CSSTransition, {\n        classNames: transitionName,\n        key: \"__backdrop\",\n        timeout: transitionDuration,\n        addEndListener: this.handleTransitionAddEnd\n      }, React.createElement(\"div\", __assign({}, backdropProps, {\n        className: classNames(Classes.OVERLAY_BACKDROP, backdropClassName, backdropProps === null || backdropProps === void 0 ? void 0 : backdropProps.className),\n        onMouseDown: this.handleBackdropMouseDown\n      })));\n    } else {\n      return null;\n    }\n  };\n  Overlay.prototype.renderDummyElement = function (key, props) {\n    var _a = this.props,\n      transitionDuration = _a.transitionDuration,\n      transitionName = _a.transitionName;\n    return React.createElement(CSSTransition, {\n      classNames: transitionName,\n      key: key,\n      addEndListener: this.handleTransitionAddEnd,\n      timeout: transitionDuration,\n      unmountOnExit: true\n    }, React.createElement(\"div\", __assign({\n      tabIndex: 0\n    }, props)));\n  };\n  Overlay.prototype.getKeyboardFocusableElements = function () {\n    var focusableElements = this.containerElement.current !== null ? Array.from(\n    // Order may not be correct if children elements use tabindex values > 0.\n    // Selectors derived from this SO question:\n    // https://stackoverflow.com/questions/1599660/which-html-elements-can-receive-focus\n    this.containerElement.current.querySelectorAll(['a[href]:not([tabindex=\"-1\"])', 'button:not([disabled]):not([tabindex=\"-1\"])', 'details:not([tabindex=\"-1\"])', 'input:not([disabled]):not([tabindex=\"-1\"])', 'select:not([disabled]):not([tabindex=\"-1\"])', 'textarea:not([disabled]):not([tabindex=\"-1\"])', '[tabindex]:not([tabindex=\"-1\"])'].join(\",\"))) : [];\n    return focusableElements.filter(function (el) {\n      return !el.classList.contains(Classes.OVERLAY_START_FOCUS_TRAP) && !el.classList.contains(Classes.OVERLAY_END_FOCUS_TRAP);\n    });\n  };\n  Overlay.prototype.overlayWillClose = function () {\n    document.removeEventListener(\"focus\", this.handleDocumentFocus, /* useCapture */true);\n    document.removeEventListener(\"mousedown\", this.handleDocumentClick);\n    var openStack = Overlay.openStack;\n    var stackIndex = openStack.indexOf(this);\n    if (stackIndex !== -1) {\n      openStack.splice(stackIndex, 1);\n      if (openStack.length > 0) {\n        var lastOpenedOverlay = Overlay.getLastOpened();\n        // Only bring focus back to last overlay if it had autoFocus _and_ enforceFocus enabled.\n        // If `autoFocus={false}`, it's likely that the overlay never received focus in the first place,\n        // so it would be surprising for us to send it there. See https://github.com/palantir/blueprint/issues/4921\n        if (lastOpenedOverlay.props.autoFocus && lastOpenedOverlay.props.enforceFocus) {\n          lastOpenedOverlay.bringFocusInsideOverlay();\n          document.addEventListener(\"focus\", lastOpenedOverlay.handleDocumentFocus, /* useCapture */true);\n        }\n      }\n      if (openStack.filter(function (o) {\n        return o.props.usePortal && o.props.hasBackdrop;\n      }).length === 0) {\n        document.body.classList.remove(Classes.OVERLAY_OPEN);\n      }\n    }\n  };\n  Overlay.prototype.overlayWillOpen = function () {\n    var getLastOpened = Overlay.getLastOpened,\n      openStack = Overlay.openStack;\n    if (openStack.length > 0) {\n      document.removeEventListener(\"focus\", getLastOpened().handleDocumentFocus, /* useCapture */true);\n    }\n    openStack.push(this);\n    if (this.props.autoFocus) {\n      this.isAutoFocusing = true;\n      this.bringFocusInsideOverlay();\n    }\n    if (this.props.enforceFocus) {\n      // Focus events do not bubble, but setting useCapture allows us to listen in and execute\n      // our handler before all others\n      document.addEventListener(\"focus\", this.handleDocumentFocus, /* useCapture */true);\n    }\n    if (this.props.canOutsideClickClose && !this.props.hasBackdrop) {\n      document.addEventListener(\"mousedown\", this.handleDocumentClick);\n    }\n    if (this.props.hasBackdrop && this.props.usePortal) {\n      // add a class to the body to prevent scrolling of content below the overlay\n      document.body.classList.add(Classes.OVERLAY_OPEN);\n    }\n    this.lastActiveElementBeforeOpened = getActiveElement(this.containerElement.current);\n  };\n  Overlay.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".Overlay\");\n  Overlay.defaultProps = {\n    autoFocus: true,\n    backdropProps: {},\n    canEscapeKeyClose: true,\n    canOutsideClickClose: true,\n    enforceFocus: true,\n    hasBackdrop: true,\n    isOpen: false,\n    lazy: true,\n    shouldReturnFocusOnClose: true,\n    transitionDuration: 300,\n    transitionName: Classes.OVERLAY,\n    usePortal: true\n  };\n  Overlay.openStack = [];\n  Overlay.getLastOpened = function () {\n    return Overlay.openStack[Overlay.openStack.length - 1];\n  };\n  return Overlay;\n}(AbstractPureComponent);\nexport { Overlay };","map":{"version":3,"names":["classNames","React","CSSTransition","TransitionGroup","AbstractPureComponent","Classes","DISPLAYNAME_PREFIX","getActiveElement","isFunction","Portal","Overlay","_super","__extends","_this","apply","arguments","isAutoFocusing","state","hasEverOpened","props","isOpen","containerElement","createRef","startFocusTrapElement","endFocusTrapElement","maybeRenderChild","child","tabIndex","enforceFocus","autoFocus","undefined","decoratedChild","cloneElement","className","OVERLAY_CONTENT","createElement","_a","onOpening","onOpened","onClosing","transitionDuration","transitionName","onEntering","onEntered","onExiting","onExited","handleTransitionExited","timeout","addEndListener","handleTransitionAddEnd","handleStartFocusTrapElementFocus","e","relatedTarget","current","contains","_b","focus","preventScroll","handleStartFocusTrapElementKeyDown","shiftKey","key","lastFocusableElement","getKeyboardFocusableElements","pop","handleEndFocusTrapElementFocus","firstFocusableElement","shift","_c","node","shouldReturnFocusOnClose","lastActiveElementBeforeOpened","HTMLElement","onClosed","call","handleBackdropMouseDown","backdropProps","canOutsideClickClose","onClose","bringFocusInsideOverlay","onMouseDown","handleDocumentClick","eventTarget","composed","composedPath","target","stackIndex","openStack","indexOf","isClickInThisOverlayOrDescendant","slice","some","elem","isSameNode","handleDocumentFocus","Node","preventDefault","stopImmediatePropagation","handleKeyDown","canEscapeKeyClose","stopPropagation","getDerivedStateFromProps","prototype","render","lazy","children","usePortal","childrenWithTransitions","Children","map","maybeBackdrop","maybeRenderBackdrop","unshift","length","renderDummyElement","OVERLAY_START_FOCUS_TRAP","onFocus","onKeyDown","ref","push","OVERLAY_END_FOCUS_TRAP","containerClasses","OVERLAY","OVERLAY_OPEN","OVERLAY_INLINE","transitionGroup","appear","component","portalClassName","container","portalContainer","stopPropagationEvents","portalStopPropagationEvents","componentDidMount","overlayWillOpen","componentDidUpdate","prevProps","overlayWillClose","componentWillUnmount","requestAnimationFrame","activeElement","isFocusOutsideModal","backdropClassName","hasBackdrop","__assign","OVERLAY_BACKDROP","unmountOnExit","focusableElements","Array","from","querySelectorAll","join","filter","el","classList","document","removeEventListener","splice","lastOpenedOverlay","getLastOpened","addEventListener","o","body","remove","add","displayName","concat","defaultProps"],"sources":["/home/meander/Desktop/Akash/Workit/my-app/node_modules/@blueprintjs/core/src/components/overlay/overlay.tsx"],"sourcesContent":["/*\n * Copyright 2015 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { CSSTransition, TransitionGroup } from \"react-transition-group\";\n\nimport { AbstractPureComponent, Classes } from \"../../common\";\nimport { DISPLAYNAME_PREFIX, HTMLDivProps, Props } from \"../../common/props\";\nimport { getActiveElement, isFunction } from \"../../common/utils\";\nimport { Portal } from \"../portal/portal\";\n\nexport interface OverlayableProps extends OverlayLifecycleProps {\n    /**\n     * Whether the overlay should acquire application focus when it first opens.\n     *\n     * @default true\n     */\n    autoFocus?: boolean;\n\n    /**\n     * Whether pressing the `esc` key should invoke `onClose`.\n     *\n     * @default true\n     */\n    canEscapeKeyClose?: boolean;\n\n    /**\n     * Whether the overlay should prevent focus from leaving itself. That is, if the user attempts\n     * to focus an element outside the overlay and this prop is enabled, then the overlay will\n     * immediately bring focus back to itself. If you are nesting overlay components, either disable\n     * this prop on the \"outermost\" overlays or mark the nested ones `usePortal={false}`.\n     *\n     * @default true\n     */\n    enforceFocus?: boolean;\n\n    /**\n     * If `true` and `usePortal={true}`, the `Portal` containing the children is created and attached\n     * to the DOM when the overlay is opened for the first time; otherwise this happens when the\n     * component mounts. Lazy mounting provides noticeable performance improvements if you have lots\n     * of overlays at once, such as on each row of a table.\n     *\n     * @default true\n     */\n    lazy?: boolean;\n\n    /**\n     * Whether the application should return focus to the last active element in the\n     * document after this overlay closes.\n     *\n     * @default true\n     */\n    shouldReturnFocusOnClose?: boolean;\n\n    /**\n     * Indicates how long (in milliseconds) the overlay's enter/leave transition takes.\n     * This is used by React `CSSTransition` to know when a transition completes and must match\n     * the duration of the animation in CSS. Only set this prop if you override Blueprint's default\n     * transitions with new transitions of a different length.\n     *\n     * @default 300\n     */\n    transitionDuration?: number;\n\n    /**\n     * Whether the overlay should be wrapped in a `Portal`, which renders its contents in a new\n     * element attached to `portalContainer` prop.\n     *\n     * This prop essentially determines which element is covered by the backdrop: if `false`,\n     * then only its parent is covered; otherwise, the entire page is covered (because the parent\n     * of the `Portal` is the `<body>` itself).\n     *\n     * Set this prop to `false` on nested overlays (such as `Dialog` or `Popover`) to ensure that they\n     * are rendered above their parents.\n     *\n     * @default true\n     */\n    usePortal?: boolean;\n\n    /**\n     * Space-delimited string of class names applied to the `Portal` element if\n     * `usePortal={true}`.\n     */\n    portalClassName?: string;\n\n    /**\n     * The container element into which the overlay renders its contents, when `usePortal` is `true`.\n     * This prop is ignored if `usePortal` is `false`.\n     *\n     * @default document.body\n     */\n    portalContainer?: HTMLElement;\n\n    /**\n     * A list of DOM events which should be stopped from propagating through the Portal.\n     * This prop is ignored if `usePortal` is `false`.\n     *\n     * @see https://legacy.reactjs.org/docs/portals.html#event-bubbling-through-portals\n     * @see https://github.com/palantir/blueprint/issues/6124\n     */\n    portalStopPropagationEvents?: Array<keyof HTMLElementEventMap>;\n\n    /**\n     * A callback that is invoked when user interaction causes the overlay to close, such as\n     * clicking on the overlay or pressing the `esc` key (if enabled).\n     *\n     * Receives the event from the user's interaction, if there was an event (generally either a\n     * mouse or key event). Note that, since this component is controlled by the `isOpen` prop, it\n     * will not actually close itself until that prop becomes `false`.\n     */\n    onClose?: (event: React.SyntheticEvent<HTMLElement>) => void;\n}\n\nexport interface OverlayLifecycleProps {\n    /**\n     * Lifecycle method invoked just before the CSS _close_ transition begins on\n     * a child. Receives the DOM element of the child being closed.\n     */\n    onClosing?: (node: HTMLElement) => void;\n\n    /**\n     * Lifecycle method invoked just after the CSS _close_ transition ends but\n     * before the child has been removed from the DOM. Receives the DOM element\n     * of the child being closed.\n     */\n    onClosed?: (node: HTMLElement) => void;\n\n    /**\n     * Lifecycle method invoked just after mounting the child in the DOM but\n     * just before the CSS _open_ transition begins. Receives the DOM element of\n     * the child being opened.\n     */\n    onOpening?: (node: HTMLElement) => void;\n\n    /**\n     * Lifecycle method invoked just after the CSS _open_ transition ends.\n     * Receives the DOM element of the child being opened.\n     */\n    onOpened?: (node: HTMLElement) => void;\n}\n\nexport interface BackdropProps {\n    /** CSS class names to apply to backdrop element. */\n    backdropClassName?: string;\n\n    /** HTML props for the backdrop element. */\n    backdropProps?: React.HTMLProps<HTMLDivElement>;\n\n    /**\n     * Whether clicking outside the overlay element (either on backdrop when present or on document)\n     * should invoke `onClose`.\n     *\n     * @default true\n     */\n    canOutsideClickClose?: boolean;\n\n    /**\n     * Whether a container-spanning backdrop element should be rendered behind the contents.\n     *\n     * @default true\n     */\n    hasBackdrop?: boolean;\n}\n\nexport interface OverlayProps extends OverlayableProps, BackdropProps, Props {\n    /** Element to overlay. */\n    children?: React.ReactNode;\n\n    /**\n     * Toggles the visibility of the overlay and its children.\n     * This prop is required because the component is controlled.\n     */\n    isOpen: boolean;\n\n    /**\n     * Name of the transition for internal `CSSTransition`.\n     * Providing your own name here will require defining new CSS transition properties.\n     *\n     * @default Classes.OVERLAY\n     */\n    transitionName?: string;\n}\n\nexport interface OverlayState {\n    hasEverOpened?: boolean;\n}\n\n/**\n * Overlay component.\n *\n * @see https://blueprintjs.com/docs/#core/components/overlay\n */\nexport class Overlay extends AbstractPureComponent<OverlayProps, OverlayState> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.Overlay`;\n\n    public static defaultProps: OverlayProps = {\n        autoFocus: true,\n        backdropProps: {},\n        canEscapeKeyClose: true,\n        canOutsideClickClose: true,\n        enforceFocus: true,\n        hasBackdrop: true,\n        isOpen: false,\n        lazy: true,\n        shouldReturnFocusOnClose: true,\n        transitionDuration: 300,\n        transitionName: Classes.OVERLAY,\n        usePortal: true,\n    };\n\n    public static getDerivedStateFromProps({ isOpen: hasEverOpened }: OverlayProps) {\n        if (hasEverOpened) {\n            return { hasEverOpened };\n        }\n        return null;\n    }\n\n    private static openStack: Overlay[] = [];\n\n    private static getLastOpened = () => Overlay.openStack[Overlay.openStack.length - 1];\n\n    private isAutoFocusing = false;\n\n    private lastActiveElementBeforeOpened: Element | null | undefined;\n\n    public state: OverlayState = {\n        hasEverOpened: this.props.isOpen,\n    };\n\n    /** Ref for container element, containing all children and the backdrop */\n    public containerElement = React.createRef<HTMLDivElement>();\n\n    // An empty, keyboard-focusable div at the beginning of the Overlay content\n    private startFocusTrapElement = React.createRef<HTMLDivElement>();\n\n    // An empty, keyboard-focusable div at the end of the Overlay content\n    private endFocusTrapElement = React.createRef<HTMLDivElement>();\n\n    public render() {\n        // oh snap! no reason to render anything at all if we're being truly lazy\n        if (this.props.lazy && !this.state.hasEverOpened) {\n            return null;\n        }\n\n        const { autoFocus, children, className, enforceFocus, usePortal, isOpen } = this.props;\n\n        // TransitionGroup types require single array of children; does not support nested arrays.\n        // So we must collapse backdrop and children into one array, and every item must be wrapped in a\n        // Transition element (no ReactText allowed).\n        const childrenWithTransitions = isOpen ? React.Children.map(children, this.maybeRenderChild) ?? [] : [];\n\n        const maybeBackdrop = this.maybeRenderBackdrop();\n        if (maybeBackdrop !== null) {\n            childrenWithTransitions.unshift(maybeBackdrop);\n        }\n        if (isOpen && (autoFocus || enforceFocus) && childrenWithTransitions.length > 0) {\n            childrenWithTransitions.unshift(\n                this.renderDummyElement(\"__start\", {\n                    className: Classes.OVERLAY_START_FOCUS_TRAP,\n                    onFocus: this.handleStartFocusTrapElementFocus,\n                    onKeyDown: this.handleStartFocusTrapElementKeyDown,\n                    ref: this.startFocusTrapElement,\n                }),\n            );\n            if (enforceFocus) {\n                childrenWithTransitions.push(\n                    this.renderDummyElement(\"__end\", {\n                        className: Classes.OVERLAY_END_FOCUS_TRAP,\n                        onFocus: this.handleEndFocusTrapElementFocus,\n                        ref: this.endFocusTrapElement,\n                    }),\n                );\n            }\n        }\n\n        const containerClasses = classNames(\n            Classes.OVERLAY,\n            {\n                [Classes.OVERLAY_OPEN]: isOpen,\n                [Classes.OVERLAY_INLINE]: !usePortal,\n            },\n            className,\n        );\n\n        const transitionGroup = (\n            <div\n                aria-live=\"polite\"\n                className={containerClasses}\n                onKeyDown={this.handleKeyDown}\n                ref={this.containerElement}\n            >\n                <TransitionGroup appear={true} component={null}>\n                    {childrenWithTransitions}\n                </TransitionGroup>\n            </div>\n        );\n        if (usePortal) {\n            return (\n                <Portal\n                    className={this.props.portalClassName}\n                    container={this.props.portalContainer}\n                    stopPropagationEvents={this.props.portalStopPropagationEvents}\n                >\n                    {transitionGroup}\n                </Portal>\n            );\n        } else {\n            return transitionGroup;\n        }\n    }\n\n    public componentDidMount() {\n        if (this.props.isOpen) {\n            this.overlayWillOpen();\n        }\n    }\n\n    public componentDidUpdate(prevProps: OverlayProps) {\n        if (prevProps.isOpen && !this.props.isOpen) {\n            this.overlayWillClose();\n        } else if (!prevProps.isOpen && this.props.isOpen) {\n            this.overlayWillOpen();\n        }\n    }\n\n    public componentWillUnmount() {\n        this.overlayWillClose();\n    }\n\n    /**\n     * @public for testing\n     * @internal\n     */\n    public bringFocusInsideOverlay() {\n        // always delay focus manipulation to just before repaint to prevent scroll jumping\n        return this.requestAnimationFrame(() => {\n            // container element may be undefined between component mounting and Portal rendering\n            // activeElement may be undefined in some rare cases in IE\n            const activeElement = getActiveElement(this.containerElement.current);\n\n            if (this.containerElement.current == null || activeElement == null || !this.props.isOpen) {\n                return;\n            }\n\n            const container = this.containerElement.current;\n            const isFocusOutsideModal = !container.contains(activeElement);\n            if (isFocusOutsideModal) {\n                this.startFocusTrapElement.current?.focus({ preventScroll: true });\n                this.isAutoFocusing = false;\n            }\n        });\n    }\n\n    private maybeRenderChild = (child?: React.ReactNode) => {\n        if (isFunction(child)) {\n            child = child();\n        }\n\n        if (child == null) {\n            return null;\n        }\n\n        // decorate the child with a few injected props\n        const tabIndex = this.props.enforceFocus || this.props.autoFocus ? 0 : undefined;\n        const decoratedChild =\n            typeof child === \"object\" ? (\n                React.cloneElement(child as React.ReactElement, {\n                    className: classNames((child as React.ReactElement).props.className, Classes.OVERLAY_CONTENT),\n                    tabIndex,\n                })\n            ) : (\n                <span className={Classes.OVERLAY_CONTENT} tabIndex={tabIndex}>\n                    {child}\n                </span>\n            );\n\n        const { onOpening, onOpened, onClosing, transitionDuration, transitionName } = this.props;\n\n        return (\n            <CSSTransition\n                classNames={transitionName}\n                onEntering={onOpening}\n                onEntered={onOpened}\n                onExiting={onClosing}\n                onExited={this.handleTransitionExited}\n                timeout={transitionDuration}\n                addEndListener={this.handleTransitionAddEnd}\n            >\n                {decoratedChild}\n            </CSSTransition>\n        );\n    };\n\n    private maybeRenderBackdrop() {\n        const { backdropClassName, backdropProps, hasBackdrop, isOpen, transitionDuration, transitionName } =\n            this.props;\n\n        if (hasBackdrop && isOpen) {\n            return (\n                <CSSTransition\n                    classNames={transitionName}\n                    key=\"__backdrop\"\n                    timeout={transitionDuration}\n                    addEndListener={this.handleTransitionAddEnd}\n                >\n                    <div\n                        {...backdropProps}\n                        className={classNames(Classes.OVERLAY_BACKDROP, backdropClassName, backdropProps?.className)}\n                        onMouseDown={this.handleBackdropMouseDown}\n                    />\n                </CSSTransition>\n            );\n        } else {\n            return null;\n        }\n    }\n\n    private renderDummyElement(key: string, props: HTMLDivProps & { ref?: React.Ref<HTMLDivElement> }) {\n        const { transitionDuration, transitionName } = this.props;\n        return (\n            <CSSTransition\n                classNames={transitionName}\n                key={key}\n                addEndListener={this.handleTransitionAddEnd}\n                timeout={transitionDuration}\n                unmountOnExit={true}\n            >\n                <div tabIndex={0} {...props} />\n            </CSSTransition>\n        );\n    }\n\n    /**\n     * Ensures repeatedly pressing shift+tab keeps focus inside the Overlay. Moves focus to\n     * the `endFocusTrapElement` or the first keyboard-focusable element in the Overlay (excluding\n     * the `startFocusTrapElement`), depending on whether the element losing focus is inside the\n     * Overlay.\n     */\n    private handleStartFocusTrapElementFocus = (e: React.FocusEvent<HTMLDivElement>) => {\n        if (!this.props.enforceFocus || this.isAutoFocusing) {\n            return;\n        }\n        // e.relatedTarget will not be defined if this was a programmatic focus event, as is the\n        // case when we call this.bringFocusInsideOverlay() after a user clicked on the backdrop.\n        // Otherwise, we're handling a user interaction, and we should wrap around to the last\n        // element in this transition group.\n        if (\n            e.relatedTarget != null &&\n            this.containerElement.current?.contains(e.relatedTarget as Element) &&\n            e.relatedTarget !== this.endFocusTrapElement.current\n        ) {\n            this.endFocusTrapElement.current?.focus({ preventScroll: true });\n        }\n    };\n\n    /**\n     * Wrap around to the end of the dialog if `enforceFocus` is enabled.\n     */\n    private handleStartFocusTrapElementKeyDown = (e: React.KeyboardEvent<HTMLDivElement>) => {\n        if (!this.props.enforceFocus) {\n            return;\n        }\n        if (e.shiftKey && e.key === \"Tab\") {\n            const lastFocusableElement = this.getKeyboardFocusableElements().pop();\n            if (lastFocusableElement != null) {\n                lastFocusableElement.focus();\n            } else {\n                this.endFocusTrapElement.current?.focus({ preventScroll: true });\n            }\n        }\n    };\n\n    /**\n     * Ensures repeatedly pressing tab keeps focus inside the Overlay. Moves focus to the\n     * `startFocusTrapElement` or the last keyboard-focusable element in the Overlay (excluding the\n     * `startFocusTrapElement`), depending on whether the element losing focus is inside the\n     * Overlay.\n     */\n    private handleEndFocusTrapElementFocus = (e: React.FocusEvent<HTMLDivElement>) => {\n        // No need for this.props.enforceFocus check here because this element is only rendered\n        // when that prop is true.\n        // During user interactions, e.relatedTarget will be defined, and we should wrap around to the\n        // \"start focus trap\" element.\n        // Otherwise, we're handling a programmatic focus event, which can only happen after a user\n        // presses shift+tab from the first focusable element in the overlay.\n        if (\n            e.relatedTarget != null &&\n            this.containerElement.current?.contains(e.relatedTarget as Element) &&\n            e.relatedTarget !== this.startFocusTrapElement.current\n        ) {\n            const firstFocusableElement = this.getKeyboardFocusableElements().shift();\n            // ensure we don't re-focus an already active element by comparing against e.relatedTarget\n            if (!this.isAutoFocusing && firstFocusableElement != null && firstFocusableElement !== e.relatedTarget) {\n                firstFocusableElement.focus();\n            } else {\n                this.startFocusTrapElement.current?.focus({ preventScroll: true });\n            }\n        } else {\n            const lastFocusableElement = this.getKeyboardFocusableElements().pop();\n            if (lastFocusableElement != null) {\n                lastFocusableElement.focus();\n            } else {\n                // Keeps focus within Overlay even if there are no keyboard-focusable children\n                this.startFocusTrapElement.current?.focus({ preventScroll: true });\n            }\n        }\n    };\n\n    private getKeyboardFocusableElements() {\n        const focusableElements: HTMLElement[] =\n            this.containerElement.current !== null\n                ? Array.from(\n                      // Order may not be correct if children elements use tabindex values > 0.\n                      // Selectors derived from this SO question:\n                      // https://stackoverflow.com/questions/1599660/which-html-elements-can-receive-focus\n                      this.containerElement.current.querySelectorAll(\n                          [\n                              'a[href]:not([tabindex=\"-1\"])',\n                              'button:not([disabled]):not([tabindex=\"-1\"])',\n                              'details:not([tabindex=\"-1\"])',\n                              'input:not([disabled]):not([tabindex=\"-1\"])',\n                              'select:not([disabled]):not([tabindex=\"-1\"])',\n                              'textarea:not([disabled]):not([tabindex=\"-1\"])',\n                              '[tabindex]:not([tabindex=\"-1\"])',\n                          ].join(\",\"),\n                      ),\n                  )\n                : [];\n\n        return focusableElements.filter(\n            el =>\n                !el.classList.contains(Classes.OVERLAY_START_FOCUS_TRAP) &&\n                !el.classList.contains(Classes.OVERLAY_END_FOCUS_TRAP),\n        );\n    }\n\n    private overlayWillClose() {\n        document.removeEventListener(\"focus\", this.handleDocumentFocus, /* useCapture */ true);\n        document.removeEventListener(\"mousedown\", this.handleDocumentClick);\n\n        const { openStack } = Overlay;\n        const stackIndex = openStack.indexOf(this);\n        if (stackIndex !== -1) {\n            openStack.splice(stackIndex, 1);\n            if (openStack.length > 0) {\n                const lastOpenedOverlay = Overlay.getLastOpened();\n                // Only bring focus back to last overlay if it had autoFocus _and_ enforceFocus enabled.\n                // If `autoFocus={false}`, it's likely that the overlay never received focus in the first place,\n                // so it would be surprising for us to send it there. See https://github.com/palantir/blueprint/issues/4921\n                if (lastOpenedOverlay.props.autoFocus && lastOpenedOverlay.props.enforceFocus) {\n                    lastOpenedOverlay.bringFocusInsideOverlay();\n                    document.addEventListener(\"focus\", lastOpenedOverlay.handleDocumentFocus, /* useCapture */ true);\n                }\n            }\n\n            if (openStack.filter(o => o.props.usePortal && o.props.hasBackdrop).length === 0) {\n                document.body.classList.remove(Classes.OVERLAY_OPEN);\n            }\n        }\n    }\n\n    private overlayWillOpen() {\n        const { getLastOpened, openStack } = Overlay;\n        if (openStack.length > 0) {\n            document.removeEventListener(\"focus\", getLastOpened().handleDocumentFocus, /* useCapture */ true);\n        }\n        openStack.push(this);\n\n        if (this.props.autoFocus) {\n            this.isAutoFocusing = true;\n            this.bringFocusInsideOverlay();\n        }\n\n        if (this.props.enforceFocus) {\n            // Focus events do not bubble, but setting useCapture allows us to listen in and execute\n            // our handler before all others\n            document.addEventListener(\"focus\", this.handleDocumentFocus, /* useCapture */ true);\n        }\n\n        if (this.props.canOutsideClickClose && !this.props.hasBackdrop) {\n            document.addEventListener(\"mousedown\", this.handleDocumentClick);\n        }\n\n        if (this.props.hasBackdrop && this.props.usePortal) {\n            // add a class to the body to prevent scrolling of content below the overlay\n            document.body.classList.add(Classes.OVERLAY_OPEN);\n        }\n\n        this.lastActiveElementBeforeOpened = getActiveElement(this.containerElement.current);\n    }\n\n    private handleTransitionExited = (node: HTMLElement) => {\n        if (this.props.shouldReturnFocusOnClose && this.lastActiveElementBeforeOpened instanceof HTMLElement) {\n            this.lastActiveElementBeforeOpened.focus();\n        }\n        this.props.onClosed?.(node);\n    };\n\n    private handleBackdropMouseDown = (e: React.MouseEvent<HTMLDivElement>) => {\n        const { backdropProps, canOutsideClickClose, enforceFocus, onClose } = this.props;\n        if (canOutsideClickClose) {\n            onClose?.(e);\n        }\n        if (enforceFocus) {\n            this.bringFocusInsideOverlay();\n        }\n        backdropProps?.onMouseDown?.(e);\n    };\n\n    private handleDocumentClick = (e: MouseEvent) => {\n        const { canOutsideClickClose, isOpen, onClose } = this.props;\n        // get the actual target even in the Shadow DOM\n        // see https://github.com/palantir/blueprint/issues/4220\n        const eventTarget = (e.composed ? e.composedPath()[0] : e.target) as HTMLElement;\n\n        const stackIndex = Overlay.openStack.indexOf(this);\n        const isClickInThisOverlayOrDescendant = Overlay.openStack\n            .slice(stackIndex)\n            .some(({ containerElement: elem }) => {\n                // `elem` is the container of backdrop & content, so clicking directly on that container\n                // should not count as being \"inside\" the overlay.\n                return elem.current?.contains(eventTarget) && !elem.current.isSameNode(eventTarget);\n            });\n\n        if (isOpen && !isClickInThisOverlayOrDescendant && canOutsideClickClose) {\n            // casting to any because this is a native event\n            onClose?.(e as any);\n        }\n    };\n\n    /**\n     * When multiple Overlays are open, this event handler is only active for the most recently\n     * opened one to avoid Overlays competing with each other for focus.\n     */\n    private handleDocumentFocus = (e: FocusEvent) => {\n        // get the actual target even in the Shadow DOM\n        // see https://github.com/palantir/blueprint/issues/4220\n        const eventTarget = e.composed ? e.composedPath()[0] : e.target;\n        if (\n            this.props.enforceFocus &&\n            this.containerElement.current != null &&\n            eventTarget instanceof Node &&\n            !this.containerElement.current.contains(eventTarget as HTMLElement)\n        ) {\n            // prevent default focus behavior (sometimes auto-scrolls the page)\n            e.preventDefault();\n            e.stopImmediatePropagation();\n            this.bringFocusInsideOverlay();\n        }\n    };\n\n    private handleKeyDown = (e: React.KeyboardEvent<HTMLElement>) => {\n        const { canEscapeKeyClose, onClose } = this.props;\n        if (e.key === \"Escape\" && canEscapeKeyClose) {\n            onClose?.(e);\n            // prevent other overlays from closing\n            e.stopPropagation();\n            // prevent browser-specific escape key behavior (Safari exits fullscreen)\n            e.preventDefault();\n        }\n    };\n\n    private handleTransitionAddEnd = () => {\n        // no-op\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}