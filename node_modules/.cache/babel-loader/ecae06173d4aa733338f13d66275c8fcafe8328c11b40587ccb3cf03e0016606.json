{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Named modifier keys\n *\n * @see https://www.w3.org/TR/uievents-key/#keys-modifier\n */\nvar MODIFIER_KEYS = new Set([\"Shift\", \"Control\", \"Alt\", \"Meta\"]);\nexport var MODIFIER_BIT_MASKS = {\n  alt: 1,\n  ctrl: 2,\n  meta: 4,\n  shift: 8\n};\nexport var CONFIG_ALIASES = {\n  cmd: \"meta\",\n  command: \"meta\",\n  escape: \"escape\",\n  minus: \"-\",\n  mod: isMac() ? \"meta\" : \"ctrl\",\n  option: \"alt\",\n  plus: \"+\",\n  return: \"enter\",\n  win: \"meta\",\n  // need these aliases for backwards-compatibility (but they're also convenient)\n  up: \"ArrowUp\",\n  left: \"ArrowLeft\",\n  down: \"ArrowDown\",\n  right: \"ArrowRight\"\n};\n/**\n * Key mapping used in getKeyCombo() implementation for physical keys which are not alphabet characters or digits.\n *\n * N.B. at some point, we should stop using this mapping, since we can implement the desired functionality in a more\n * straightforward way by using the `event.code` property, which will always tell us the identifiers represented by the\n * _values_ in this object (the default physical keys, unaltered by modifier keys or keyboard layout).\n */\nexport var SHIFT_KEYS = {\n  \"~\": \"`\",\n  _: \"-\",\n  \"+\": \"=\",\n  \"{\": \"[\",\n  \"}\": \"]\",\n  \"|\": \"\\\\\",\n  \":\": \";\",\n  '\"': \"'\",\n  \"<\": \",\",\n  \">\": \".\",\n  \"?\": \"/\"\n};\nexport function comboMatches(a, b) {\n  return a.modifiers === b.modifiers && a.key === b.key;\n}\n/**\n * Converts a key combo string into a key combo object. Key combos include\n * zero or more modifier keys, such as `shift` or `alt`, and exactly one\n * action key, such as `A`, `enter`, or `left`.\n *\n * For action keys that require a shift, e.g. `@` or `|`, we inlude the\n * necessary `shift` modifier and automatically convert the action key to the\n * unshifted version. For example, `@` is equivalent to `shift+2`.\n */\nexport var parseKeyCombo = function (combo) {\n  var pieces = combo.replace(/\\s/g, \"\").toLowerCase().split(\"+\");\n  var modifiers = 0;\n  var key;\n  for (var _i = 0, pieces_1 = pieces; _i < pieces_1.length; _i++) {\n    var piece = pieces_1[_i];\n    if (piece === \"\") {\n      throw new Error(\"Failed to parse key combo \\\"\".concat(combo, \"\\\".\\n                Valid key combos look like \\\"cmd + plus\\\", \\\"shift+p\\\", or \\\"!\\\"\"));\n    }\n    if (CONFIG_ALIASES[piece] !== undefined) {\n      piece = CONFIG_ALIASES[piece];\n    }\n    if (MODIFIER_BIT_MASKS[piece] !== undefined) {\n      modifiers += MODIFIER_BIT_MASKS[piece];\n    } else if (SHIFT_KEYS[piece] !== undefined) {\n      modifiers += MODIFIER_BIT_MASKS.shift;\n      key = SHIFT_KEYS[piece];\n    } else {\n      key = piece.toLowerCase();\n    }\n  }\n  return {\n    modifiers: modifiers,\n    key: key\n  };\n};\n/**\n * Interprets a keyboard event as a valid KeyComboTag `combo` prop string value.\n *\n * Note that this function is only used in the docs example and tests; it is not used by `useHotkeys()` or any\n * Blueprint consumers that we are currently aware of.\n */\nexport var getKeyComboString = function (e) {\n  var comboParts = [];\n  // modifiers first\n  if (e.ctrlKey) {\n    comboParts.push(\"ctrl\");\n  }\n  if (e.altKey) {\n    comboParts.push(\"alt\");\n  }\n  if (e.shiftKey) {\n    comboParts.push(\"shift\");\n  }\n  if (e.metaKey) {\n    comboParts.push(\"meta\");\n  }\n  var key = maybeGetKeyFromEventCode(e);\n  if (key !== undefined) {\n    comboParts.push(key);\n  } else {\n    if (e.code === \"Space\") {\n      comboParts.push(\"space\");\n    } else if (MODIFIER_KEYS.has(e.key)) {\n      // do nothing\n    } else if (e.shiftKey && SHIFT_KEYS[e.key] !== undefined) {\n      comboParts.push(SHIFT_KEYS[e.key]);\n    } else if (e.key !== undefined) {\n      comboParts.push(e.key.toLowerCase());\n    }\n  }\n  return comboParts.join(\" + \");\n};\nvar KEY_CODE_PREFIX = \"Key\";\nvar DIGIT_CODE_PREFIX = \"Digit\";\nfunction maybeGetKeyFromEventCode(e) {\n  if (e.code == null) {\n    return undefined;\n  }\n  if (e.code.startsWith(KEY_CODE_PREFIX)) {\n    // Code looks like \"KeyA\", etc.\n    return e.code.substring(KEY_CODE_PREFIX.length).toLowerCase();\n  } else if (e.code.startsWith(DIGIT_CODE_PREFIX)) {\n    // Code looks like \"Digit1\", etc.\n    return e.code.substring(DIGIT_CODE_PREFIX.length).toLowerCase();\n  } else if (e.code === \"Space\") {\n    return \"space\";\n  }\n  return undefined;\n}\n/**\n * Determines the key combo object from the given keyboard event. A key combo includes zero or more modifiers\n * (represented by a bitmask) and one physical key. For most keys, we prefer dealing with the `code` property of the\n * event, since this is not altered by keyboard layout or the state of modifier keys. Fall back to using the `key`\n * property.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code\n */\nexport var getKeyCombo = function (e) {\n  var _a, _b;\n  var key;\n  if (MODIFIER_KEYS.has(e.key)) {\n    // Leave local variable `key` undefined\n  } else {\n    key = (_a = maybeGetKeyFromEventCode(e)) !== null && _a !== void 0 ? _a : (_b = e.key) === null || _b === void 0 ? void 0 : _b.toLowerCase();\n  }\n  var modifiers = 0;\n  if (e.altKey) {\n    modifiers += MODIFIER_BIT_MASKS.alt;\n  }\n  if (e.ctrlKey) {\n    modifiers += MODIFIER_BIT_MASKS.ctrl;\n  }\n  if (e.metaKey) {\n    modifiers += MODIFIER_BIT_MASKS.meta;\n  }\n  if (e.shiftKey) {\n    modifiers += MODIFIER_BIT_MASKS.shift;\n    if (SHIFT_KEYS[e.key] !== undefined) {\n      key = SHIFT_KEYS[e.key];\n    }\n  }\n  return {\n    modifiers: modifiers,\n    key: key\n  };\n};\n/**\n * Splits a key combo string into its constituent key values and looks up\n * aliases, such as `return` -> `enter`.\n *\n * Unlike the parseKeyCombo method, this method does NOT convert shifted\n * action keys. So `\"@\"` will NOT be converted to `[\"shift\", \"2\"]`).\n */\nexport var normalizeKeyCombo = function (combo, platformOverride) {\n  var keys = combo.replace(/\\s/g, \"\").split(\"+\");\n  return keys.map(function (key) {\n    var keyName = CONFIG_ALIASES[key] != null ? CONFIG_ALIASES[key] : key;\n    return keyName === \"meta\" ? isMac(platformOverride) ? \"cmd\" : \"ctrl\" : keyName;\n  });\n};\nfunction isMac(platformOverride) {\n  // HACKHACK: see https://github.com/palantir/blueprint/issues/5174\n  // eslint-disable-next-line deprecation/deprecation\n  var platform = platformOverride !== null && platformOverride !== void 0 ? platformOverride : typeof navigator !== \"undefined\" ? navigator.platform : undefined;\n  return platform === undefined ? false : /Mac|iPod|iPhone|iPad/.test(platform);\n}","map":{"version":3,"names":["MODIFIER_KEYS","Set","MODIFIER_BIT_MASKS","alt","ctrl","meta","shift","CONFIG_ALIASES","cmd","command","escape","minus","mod","isMac","option","plus","return","win","up","left","down","right","SHIFT_KEYS","_","comboMatches","a","b","modifiers","key","parseKeyCombo","combo","pieces","replace","toLowerCase","split","_i","pieces_1","length","piece","Error","concat","undefined","getKeyComboString","e","comboParts","ctrlKey","push","altKey","shiftKey","metaKey","maybeGetKeyFromEventCode","code","has","join","KEY_CODE_PREFIX","DIGIT_CODE_PREFIX","startsWith","substring","getKeyCombo","_a","_b","normalizeKeyCombo","platformOverride","keys","map","keyName","platform","navigator","test"],"sources":["/home/meander/Desktop/Akash/Workit/my-app/node_modules/@blueprintjs/core/src/components/hotkeys/hotkeyParser.ts"],"sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// alph sorting is unintuitive here\n// tslint:disable object-literal-sort-keys\n\nexport interface KeyCodeTable {\n    [code: number]: string;\n}\n\nexport interface KeyCodeReverseTable {\n    [key: string]: number;\n}\n\nexport interface KeyMap {\n    [key: string]: string;\n}\n\n/**\n * Named modifier keys\n *\n * @see https://www.w3.org/TR/uievents-key/#keys-modifier\n */\nconst MODIFIER_KEYS = new Set([\"Shift\", \"Control\", \"Alt\", \"Meta\"]);\n\nexport const MODIFIER_BIT_MASKS: KeyCodeReverseTable = {\n    alt: 1,\n    ctrl: 2,\n    meta: 4,\n    shift: 8,\n};\n\nexport const CONFIG_ALIASES: KeyMap = {\n    cmd: \"meta\",\n    command: \"meta\",\n    escape: \"escape\",\n    minus: \"-\",\n    mod: isMac() ? \"meta\" : \"ctrl\",\n    option: \"alt\",\n    plus: \"+\",\n    return: \"enter\",\n    win: \"meta\",\n    // need these aliases for backwards-compatibility (but they're also convenient)\n    up: \"ArrowUp\",\n    left: \"ArrowLeft\",\n    down: \"ArrowDown\",\n    right: \"ArrowRight\",\n};\n\n/**\n * Key mapping used in getKeyCombo() implementation for physical keys which are not alphabet characters or digits.\n *\n * N.B. at some point, we should stop using this mapping, since we can implement the desired functionality in a more\n * straightforward way by using the `event.code` property, which will always tell us the identifiers represented by the\n * _values_ in this object (the default physical keys, unaltered by modifier keys or keyboard layout).\n */\nexport const SHIFT_KEYS: KeyMap = {\n    \"~\": \"`\",\n    _: \"-\",\n    \"+\": \"=\",\n    \"{\": \"[\",\n    \"}\": \"]\",\n    \"|\": \"\\\\\",\n    \":\": \";\",\n    '\"': \"'\",\n    \"<\": \",\",\n    \">\": \".\",\n    \"?\": \"/\",\n};\n\nexport interface KeyCombo {\n    key?: string;\n    modifiers: number;\n}\n\nexport function comboMatches(a: KeyCombo, b: KeyCombo) {\n    return a.modifiers === b.modifiers && a.key === b.key;\n}\n\n/**\n * Converts a key combo string into a key combo object. Key combos include\n * zero or more modifier keys, such as `shift` or `alt`, and exactly one\n * action key, such as `A`, `enter`, or `left`.\n *\n * For action keys that require a shift, e.g. `@` or `|`, we inlude the\n * necessary `shift` modifier and automatically convert the action key to the\n * unshifted version. For example, `@` is equivalent to `shift+2`.\n */\nexport const parseKeyCombo = (combo: string): KeyCombo => {\n    const pieces = combo.replace(/\\s/g, \"\").toLowerCase().split(\"+\");\n    let modifiers = 0;\n    let key: string | undefined;\n    for (let piece of pieces) {\n        if (piece === \"\") {\n            throw new Error(`Failed to parse key combo \"${combo}\".\n                Valid key combos look like \"cmd + plus\", \"shift+p\", or \"!\"`);\n        }\n\n        if (CONFIG_ALIASES[piece] !== undefined) {\n            piece = CONFIG_ALIASES[piece];\n        }\n\n        if (MODIFIER_BIT_MASKS[piece] !== undefined) {\n            modifiers += MODIFIER_BIT_MASKS[piece];\n        } else if (SHIFT_KEYS[piece] !== undefined) {\n            modifiers += MODIFIER_BIT_MASKS.shift;\n            key = SHIFT_KEYS[piece];\n        } else {\n            key = piece.toLowerCase();\n        }\n    }\n    return { modifiers, key };\n};\n\n/**\n * Interprets a keyboard event as a valid KeyComboTag `combo` prop string value.\n *\n * Note that this function is only used in the docs example and tests; it is not used by `useHotkeys()` or any\n * Blueprint consumers that we are currently aware of.\n */\nexport const getKeyComboString = (e: KeyboardEvent): string => {\n    const comboParts = [] as string[];\n\n    // modifiers first\n    if (e.ctrlKey) {\n        comboParts.push(\"ctrl\");\n    }\n    if (e.altKey) {\n        comboParts.push(\"alt\");\n    }\n    if (e.shiftKey) {\n        comboParts.push(\"shift\");\n    }\n    if (e.metaKey) {\n        comboParts.push(\"meta\");\n    }\n\n    const key = maybeGetKeyFromEventCode(e);\n    if (key !== undefined) {\n        comboParts.push(key);\n    } else {\n        if (e.code === \"Space\") {\n            comboParts.push(\"space\");\n        } else if (MODIFIER_KEYS.has(e.key)) {\n            // do nothing\n        } else if (e.shiftKey && SHIFT_KEYS[e.key] !== undefined) {\n            comboParts.push(SHIFT_KEYS[e.key]);\n        } else if (e.key !== undefined) {\n            comboParts.push(e.key.toLowerCase());\n        }\n    }\n\n    return comboParts.join(\" + \");\n};\n\nconst KEY_CODE_PREFIX = \"Key\";\nconst DIGIT_CODE_PREFIX = \"Digit\";\n\nfunction maybeGetKeyFromEventCode(e: KeyboardEvent) {\n    if (e.code == null) {\n        return undefined;\n    }\n\n    if (e.code.startsWith(KEY_CODE_PREFIX)) {\n        // Code looks like \"KeyA\", etc.\n        return e.code.substring(KEY_CODE_PREFIX.length).toLowerCase();\n    } else if (e.code.startsWith(DIGIT_CODE_PREFIX)) {\n        // Code looks like \"Digit1\", etc.\n        return e.code.substring(DIGIT_CODE_PREFIX.length).toLowerCase();\n    } else if (e.code === \"Space\") {\n        return \"space\";\n    }\n\n    return undefined;\n}\n\n/**\n * Determines the key combo object from the given keyboard event. A key combo includes zero or more modifiers\n * (represented by a bitmask) and one physical key. For most keys, we prefer dealing with the `code` property of the\n * event, since this is not altered by keyboard layout or the state of modifier keys. Fall back to using the `key`\n * property.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code\n */\nexport const getKeyCombo = (e: KeyboardEvent): KeyCombo => {\n    let key: string | undefined;\n    if (MODIFIER_KEYS.has(e.key)) {\n        // Leave local variable `key` undefined\n    } else {\n        key = maybeGetKeyFromEventCode(e) ?? e.key?.toLowerCase();\n    }\n\n    let modifiers = 0;\n    if (e.altKey) {\n        modifiers += MODIFIER_BIT_MASKS.alt;\n    }\n    if (e.ctrlKey) {\n        modifiers += MODIFIER_BIT_MASKS.ctrl;\n    }\n    if (e.metaKey) {\n        modifiers += MODIFIER_BIT_MASKS.meta;\n    }\n    if (e.shiftKey) {\n        modifiers += MODIFIER_BIT_MASKS.shift;\n        if (SHIFT_KEYS[e.key] !== undefined) {\n            key = SHIFT_KEYS[e.key];\n        }\n    }\n\n    return { modifiers, key };\n};\n\n/**\n * Splits a key combo string into its constituent key values and looks up\n * aliases, such as `return` -> `enter`.\n *\n * Unlike the parseKeyCombo method, this method does NOT convert shifted\n * action keys. So `\"@\"` will NOT be converted to `[\"shift\", \"2\"]`).\n */\nexport const normalizeKeyCombo = (combo: string, platformOverride?: string): string[] => {\n    const keys = combo.replace(/\\s/g, \"\").split(\"+\");\n    return keys.map(key => {\n        const keyName = CONFIG_ALIASES[key] != null ? CONFIG_ALIASES[key] : key;\n        return keyName === \"meta\" ? (isMac(platformOverride) ? \"cmd\" : \"ctrl\") : keyName;\n    });\n};\n\nfunction isMac(platformOverride?: string) {\n    // HACKHACK: see https://github.com/palantir/blueprint/issues/5174\n    // eslint-disable-next-line deprecation/deprecation\n    const platform = platformOverride ?? (typeof navigator !== \"undefined\" ? navigator.platform : undefined);\n    return platform === undefined ? false : /Mac|iPod|iPhone|iPad/.test(platform);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}